{"ast":null,"code":"import { toBitsString, toDecimal } from '../utils';\nimport { FreeCellVisitor } from './free-cell-visitor';\nimport { IsoEncoder } from './encoders/iso-encoder';\nimport { Utf8Encoder } from './encoders/utf8-encoder';\nimport { VersionsCodewordsInformation } from './version-codewords';\nimport { DataModeInstances } from './data-modes/data-mode-instances';\nvar terminator = \"0000\",\n    NUMERIC = \"numeric\",\n    ALPHA_NUMERIC = \"alphanumeric\",\n    BYTE = \"byte\",\n    powersOfTwo = {\n  \"1\": 0\n},\n    powersOfTwoResult = {\n  \"0\": 1\n},\n    irregularAlignmentPatternsStartDistance = {\n  15: 20,\n  16: 20,\n  18: 24,\n  19: 24,\n  22: 20,\n  24: 22,\n  26: 24,\n  28: 20,\n  30: 20,\n  31: 24,\n  32: 28,\n  33: 24,\n  36: 18,\n  37: 22,\n  39: 20,\n  40: 24\n},\n    finderPattern = [1, 0, 1, 1, 1],\n    alignmentPattern = [1, 0, 1],\n    errorCorrectionPatterns = {\n  L: \"01\",\n  M: \"00\",\n  Q: \"11\",\n  H: \"10\"\n},\n    formatMaskPattern = \"101010000010010\",\n    formatGeneratorPolynomial = \"10100110111\",\n    versionGeneratorPolynomial = \"1111100100101\",\n    paddingCodewords = [\"11101100\", \"00010001\"],\n    finderPatternValue = 93,\n\n/* eslint-disable arrow-body-style */\n\n/* eslint-disable no-unused-vars */\nmaskPatternConditions = [function (row, column) {\n  return (row + column) % 2 === 0;\n}, function (row, column) {\n  return row % 2 === 0;\n}, function (row, column) {\n  return column % 3 === 0;\n}, function (row, column) {\n  return (row + column) % 3 === 0;\n}, function (row, column) {\n  return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;\n}, function (row, column) {\n  return row * column % 2 + row * column % 3 === 0;\n}, function (row, column) {\n  return (row * column % 2 + row * column % 3) % 2 === 0;\n}, function (row, column) {\n  return ((row + column) % 2 + row * column % 3) % 2 === 0;\n}],\n\n/* eslint-enable no-unused-vars */\n\n/* eslint-enable arrow-body-style */\nnumberRegex = /^\\d+/,\n    alphaPattern = \"A-Z0-9 $%*+./:-\",\n    alphaExclusiveSet = \"A-Z $%*+./:-\",\n    alphaRegex = new RegExp(\"^[\" + alphaExclusiveSet + \"]+\"),\n    alphaNumericRegex = new RegExp(\"^[\" + alphaPattern + \"]+\"),\n    byteRegex = new RegExp(\"^[^\" + alphaPattern + \"]+\"),\n    initMinNumericBeforeAlpha = 8,\n    initMinNumericBeforeByte = 5,\n    initMinAlphaBeforeByte = 8,\n    minNumericBeforeAlpha = 17,\n    minNumericBeforeByte = 9,\n    minAlphaBeforeByte = 16;\nexport var generatorPolynomials = [[1, 0], [1, 25, 0]];\nexport function fillFunctionCell(matrices, bit, x, y) {\n  for (var i = 0; i < matrices.length; i++) {\n    matrices[i][x][y] = bit;\n  }\n}\nexport function fillDataCell(matrices, bit, x, y) {\n  for (var i = 0; i < maskPatternConditions.length; i++) {\n    matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);\n  }\n}\nexport function fillData(matrices, blocks) {\n  var cellVisitor = new FreeCellVisitor(matrices[0]),\n      block,\n      codewordIdx,\n      cell;\n\n  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {\n    block = blocks[blockIdx];\n    codewordIdx = 0;\n\n    while (block.length > 0) {\n      for (var i = 0; i < block.length; i++) {\n        for (var j = 0; j < 8; j++) {\n          cell = cellVisitor.getNextCell();\n          fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);\n        }\n      }\n\n      codewordIdx++;\n\n      while (block[0] && codewordIdx === block[0].length) {\n        block.splice(0, 1);\n      }\n    }\n  }\n\n  while (cell = cellVisitor.getNextRemainderCell()) {\n    fillDataCell(matrices, 0, cell.row, cell.column);\n  }\n}\nexport function padDataString(initialDataString, totalDataCodewords) {\n  var dataBitsCount = totalDataCodewords * 8,\n      terminatorIndex = 0,\n      paddingCodewordIndex = 0;\n  var dataString = initialDataString;\n\n  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {\n    dataString += terminator.charAt(terminatorIndex++);\n  }\n\n  if (dataString.length % 8 !== 0) {\n    dataString += new Array(9 - dataString.length % 8).join(\"0\");\n  }\n\n  while (dataString.length < dataBitsCount) {\n    dataString += paddingCodewords[paddingCodewordIndex];\n    paddingCodewordIndex ^= 1;\n  }\n\n  return dataString;\n}\nexport function generatePowersOfTwo() {\n  var result;\n  var power;\n\n  for (power = 1; power < 255; power++) {\n    result = powersOfTwoResult[power - 1] * 2;\n\n    if (result > 255) {\n      result = result ^ 285;\n    }\n\n    powersOfTwoResult[power] = result;\n    powersOfTwo[result] = power;\n  }\n\n  result = powersOfTwoResult[power - 1] * 2 ^ 285;\n  powersOfTwoResult[power] = result;\n  powersOfTwoResult[-1] = 0;\n}\nexport function xorPolynomials(x, y) {\n  var result = [],\n      idx = x.length - 2;\n\n  for (var i = idx; i >= 0; i--) {\n    result[i] = x[i] ^ y[i];\n  }\n\n  return result;\n}\nexport function multiplyPolynomials(x, y) {\n  var result = [];\n\n  for (var i = 0; i < x.length; i++) {\n    for (var j = 0; j < y.length; j++) {\n      if (result[i + j] === undefined) {\n        result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;\n      } else {\n        result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];\n      }\n    }\n  }\n\n  return result;\n}\nexport function generateGeneratorPolynomials() {\n  var maxErrorCorrectionCodeWordsCount = 68;\n\n  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {\n    var firstPolynomial = generatorPolynomials[idx - 1],\n        secondPolynomial = [idx, 0];\n    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);\n  }\n} //possibly generate on demand\n\ngeneratePowersOfTwo();\ngenerateGeneratorPolynomials();\nexport function multiplyByConstant(polynomial, power) {\n  var result = [],\n      idx = polynomial.length - 1;\n\n  do {\n    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];\n    idx--;\n  } while (polynomial[idx] !== undefined);\n\n  return result;\n}\nexport function generateErrorCodewords(data, errorCodewordsCount) {\n  var generator = generatorPolynomials[errorCodewordsCount - 1],\n      result = new Array(errorCodewordsCount).concat(data),\n      generatorPolynomial = new Array(result.length - generator.length).concat(generator),\n      steps = data.length,\n      errorCodewords = [],\n      divisor,\n      idx;\n\n  for (idx = 0; idx < steps; idx++) {\n    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);\n    generatorPolynomial.splice(0, 1);\n    result = xorPolynomials(divisor, result);\n  }\n\n  for (idx = result.length - 1; idx >= 0; idx--) {\n    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);\n  }\n\n  return errorCodewords;\n}\nexport function getBlocks(dataStream, versionCodewordsInformation) {\n  var codewordStart = 0,\n      dataBlocks = [],\n      errorBlocks = [],\n      dataBlock,\n      versionGroups = versionCodewordsInformation.groups,\n      blockCodewordsCount,\n      groupBlocksCount,\n      messagePolynomial,\n      codeword;\n\n  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {\n    groupBlocksCount = versionGroups[groupIdx][0];\n\n    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {\n      blockCodewordsCount = versionGroups[groupIdx][1];\n      dataBlock = [];\n      messagePolynomial = [];\n\n      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {\n        codeword = dataStream.substring(codewordStart, codewordStart + 8);\n        dataBlock.push(codeword);\n        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);\n        codewordStart += 8;\n      }\n\n      dataBlocks.push(dataBlock);\n      errorBlocks.push(generateErrorCodewords(messagePolynomial, versionCodewordsInformation.errorCodewordsPerBlock));\n    }\n  }\n\n  return [dataBlocks, errorBlocks];\n}\nexport function chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode) {\n  var numeric = numberRegex.exec(str),\n      numericMatch = numeric ? numeric[0] : \"\",\n      alpha = alphaRegex.exec(str),\n      alphaMatch = alpha ? alpha[0] : \"\",\n      alphaNumeric = alphaNumericRegex.exec(str),\n      alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : \"\",\n      mode,\n      modeString;\n\n  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {\n    mode = NUMERIC;\n    modeString = numericMatch;\n  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte || previousMode === ALPHA_NUMERIC)) {\n    mode = ALPHA_NUMERIC;\n    modeString = numericMatch || alphaMatch;\n  } else {\n    mode = BYTE;\n\n    if (alphaNumericMatch) {\n      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];\n    } else {\n      modeString = byteRegex.exec(str)[0];\n    }\n  }\n\n  return {\n    mode: mode,\n    modeString: modeString\n  };\n}\nexport function getModes(inputString) {\n  var modes = [],\n      previousMode,\n      idx = 0;\n  var str = inputString;\n  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));\n  previousMode = modes[0].mode;\n  str = str.substr(modes[0].modeString.length);\n\n  while (str.length > 0) {\n    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);\n\n    if (nextMode.mode !== previousMode) {\n      previousMode = nextMode.mode;\n      modes.push(nextMode);\n      idx++;\n    } else {\n      modes[idx].modeString += nextMode.modeString;\n    }\n\n    str = str.substr(nextMode.modeString.length);\n  }\n\n  return modes;\n}\nexport function getDataCodewordsCount(modes) {\n  var length = 0,\n      mode;\n\n  for (var i = 0; i < modes.length; i++) {\n    mode = DataModeInstances[modes[i].mode];\n    length += mode.getStringBitsLength(modes[i].modeString.length);\n  }\n\n  return Math.ceil(length / 8);\n}\nexport function getVersion(dataCodewordsCount, errorCorrectionLevel) {\n  var x = 0,\n      y = VersionsCodewordsInformation.length - 1,\n      version = Math.floor(VersionsCodewordsInformation.length / 2);\n\n  do {\n    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {\n      y = version;\n    } else {\n      x = version;\n    }\n\n    version = x + Math.floor((y - x) / 2);\n  } while (y - x > 1);\n\n  if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {\n    return version + 1;\n  }\n\n  return y + 1;\n}\nexport function getDataString(modes, version) {\n  var dataString = \"\",\n      mode;\n\n  for (var i = 0; i < modes.length; i++) {\n    mode = DataModeInstances[modes[i].mode];\n    dataString += mode.encode(modes[i].modeString, version);\n  }\n\n  return dataString;\n} //fix case all zeros\n\nexport function encodeFormatInformation(format) {\n  var formatNumber = toDecimal(format),\n      encodedString,\n      result = \"\";\n\n  if (formatNumber === 0) {\n    return \"101010000010010\";\n  }\n\n  encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);\n\n  for (var i = 0; i < encodedString.length; i++) {\n    result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);\n  }\n\n  return result;\n}\nexport function encodeBCH(value, generatorPolynomial, codeLength) {\n  var generatorNumber = toDecimal(generatorPolynomial),\n      polynomialLength = generatorPolynomial.length - 1,\n      valueNumber = value << polynomialLength,\n      length = codeLength - polynomialLength,\n      valueString = toBitsString(value, length),\n      result = dividePolynomials(valueNumber, generatorNumber);\n  result = valueString + toBitsString(result, polynomialLength);\n  return result;\n}\nexport function dividePolynomials(numberX, numberY) {\n  var yLength = numberY.toString(2).length,\n      xLength = numberX.toString(2).length;\n  var x = numberX;\n\n  do {\n    x ^= numberY << xLength - yLength;\n    xLength = x.toString(2).length;\n  } while (xLength >= yLength);\n\n  return x;\n}\nexport function getNumberAt(str, idx) {\n  return parseInt(str.charAt(idx), 10);\n}\nexport function initMatrices(version) {\n  var matrices = [],\n      modules = 17 + 4 * version;\n\n  for (var i = 0; i < maskPatternConditions.length; i++) {\n    matrices[i] = new Array(modules);\n\n    for (var j = 0; j < modules; j++) {\n      matrices[i][j] = new Array(modules);\n    }\n  }\n\n  return matrices;\n}\nexport function addFormatInformation(matrices, formatString) {\n  var matrix = matrices[0],\n      x,\n      y,\n      idx = 0,\n      length = formatString.length;\n\n  for (x = 0, y = 8; x <= 8; x++) {\n    if (x !== 6) {\n      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n  }\n\n  for (x = 8, y = 7; y >= 0; y--) {\n    if (y !== 6) {\n      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n  }\n\n  idx = 0;\n\n  for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {\n    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n  }\n\n  fillFunctionCell(matrices, 1, matrix.length - 8, 8);\n\n  for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {\n    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n  }\n}\nexport function encodeVersionInformation(version) {\n  return encodeBCH(version, versionGeneratorPolynomial, 18);\n}\nexport function addVersionInformation(matrices, dataString) {\n  var matrix = matrices[0],\n      modules = matrix.length,\n      x1 = 0,\n      y1 = modules - 11,\n      x2 = modules - 11,\n      y2 = 0,\n      quotient,\n      mod,\n      value;\n\n  for (var idx = 0; idx < dataString.length; idx++) {\n    quotient = Math.floor(idx / 3);\n    mod = idx % 3;\n    value = getNumberAt(dataString, dataString.length - idx - 1);\n    fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);\n    fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);\n  }\n}\nexport function addCentricPattern(matrices, pattern, x, y) {\n  var size = pattern.length + 2,\n      length = pattern.length + 1,\n      value;\n\n  for (var i = 0; i < pattern.length; i++) {\n    for (var j = i; j < size - i; j++) {\n      value = pattern[i];\n      fillFunctionCell(matrices, value, x + j, y + i);\n      fillFunctionCell(matrices, value, x + i, y + j);\n      fillFunctionCell(matrices, value, x + length - j, y + length - i);\n      fillFunctionCell(matrices, value, x + length - i, y + length - j);\n    }\n  }\n}\nexport function addFinderSeparator(matrices, direction, x, y) {\n  var nextX = x,\n      nextY = y,\n      matrix = matrices[0];\n\n  do {\n    fillFunctionCell(matrices, 0, nextX, y);\n    fillFunctionCell(matrices, 0, x, nextY);\n    nextX += direction[0];\n    nextY += direction[1];\n  } while (nextX >= 0 && nextX < matrix.length);\n}\nexport function addFinderPatterns(matrices) {\n  var modules = matrices[0].length;\n  addCentricPattern(matrices, finderPattern, 0, 0);\n  addFinderSeparator(matrices, [-1, -1], 7, 7);\n  addCentricPattern(matrices, finderPattern, modules - 7, 0);\n  addFinderSeparator(matrices, [1, -1], modules - 8, 7);\n  addCentricPattern(matrices, finderPattern, 0, modules - 7);\n  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);\n}\nexport function addAlignmentPatterns(matrices, version) {\n  if (version < 2) {\n    return;\n  }\n\n  var matrix = matrices[0],\n      modules = matrix.length,\n      pointsCount = Math.floor(version / 7),\n      points = [6],\n      startDistance,\n      distance,\n      idx = 0;\n\n  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {\n    distance = (modules - 13 - startDistance) / pointsCount;\n  } else {\n    startDistance = distance = (modules - 13) / (pointsCount + 1);\n  }\n\n  points.push(points[idx++] + startDistance);\n\n  while (points[idx] + distance < modules) {\n    points.push(points[idx++] + distance);\n  }\n\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < points.length; j++) {\n      if (matrix[points[i]][points[j]] === undefined) {\n        addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);\n      }\n    }\n  }\n}\nexport function addTimingFunctions(matrices) {\n  var row = 6,\n      column = 6,\n      value = 1,\n      modules = matrices[0].length;\n\n  for (var i = 8; i < modules - 8; i++) {\n    fillFunctionCell(matrices, value, row, i);\n    fillFunctionCell(matrices, value, i, column);\n    value ^= 1;\n  }\n}\nexport function scoreMaskMatrixes(matrices) {\n  var scores = [],\n      previousBits = [],\n      darkModules = [],\n      patterns = [],\n      adjacentSameBits = [],\n      matrix,\n      i,\n      row = 0,\n      column = 1,\n      modulesLength = matrices[0].length;\n\n  for (i = 0; i < matrices.length; i++) {\n    scores[i] = 0;\n    darkModules[i] = 0;\n    adjacentSameBits[i] = [0, 0];\n    patterns[i] = [0, 0];\n    previousBits[i] = [];\n  }\n\n  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {\n    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {\n      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {\n        matrix = matrices[matrixIndex];\n        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);\n\n        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {\n          scores[matrixIndex] += 3;\n        }\n\n        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);\n        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);\n        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);\n        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);\n      }\n    }\n  }\n\n  var total = modulesLength * modulesLength,\n      minIdx,\n      min = Number.MAX_VALUE;\n\n  for (i = 0; i < scores.length; i++) {\n    scores[i] += calculateDarkModulesRatioScore(darkModules[i], total);\n\n    if (scores[i] < min) {\n      min = scores[i];\n      minIdx = i;\n    }\n  }\n\n  return minIdx;\n}\nexport function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {\n  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;\n\n  if (patterns[idx][rowColumn] === finderPatternValue) {\n    scores[idx] += 40;\n  }\n}\nexport function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {\n  if (previousBits[idx][rowColumn] === bit) {\n    adjacentBits[idx][rowColumn]++;\n  } else {\n    previousBits[idx][rowColumn] = bit;\n\n    if (adjacentBits[idx][rowColumn] >= 5) {\n      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;\n    }\n\n    adjacentBits[idx][rowColumn] = 1;\n  }\n}\nexport function calculateDarkModulesRatioScore(darkModules, total) {\n  var percent = Math.floor(darkModules / total * 100),\n      mod5 = percent % 5,\n      previous = Math.abs(percent - mod5 - 50),\n      next = Math.abs(percent + 5 - mod5 - 50),\n      score = 10 * Math.min(previous / 5, next / 5);\n  return score;\n}\nexport function createQRCodeDataEncoder(encoding) {\n  if (encoding && encoding.toLowerCase().indexOf(\"utf_8\") >= 0) {\n    return new Utf8Encoder();\n  }\n\n  return new IsoEncoder();\n}\nexport function encodeData(inputString, errorCorrectionLevel, encoding) {\n  var encoder = createQRCodeDataEncoder(encoding),\n      encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel),\n      version = encodingResult.version,\n      versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel],\n      dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords),\n      blocks = getBlocks(dataString, versionInformation),\n      matrices = initMatrices(version);\n  addFinderPatterns(matrices);\n  addAlignmentPatterns(matrices, version);\n  addTimingFunctions(matrices);\n\n  if (version >= 7) {\n    addVersionInformation(matrices, toBitsString(0, 18));\n  }\n\n  addFormatInformation(matrices, toBitsString(0, 15));\n  fillData(matrices, blocks);\n  var minIdx = scoreMaskMatrixes(matrices),\n      optimalMatrix = matrices[minIdx];\n\n  if (version >= 7) {\n    addVersionInformation([optimalMatrix], encodeVersionInformation(version));\n  }\n\n  var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);\n  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));\n  return optimalMatrix;\n}","map":{"version":3,"sources":["/home/meryem/repos/Movie_Trend_Visualizer/client/node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js"],"names":["toBitsString","toDecimal","FreeCellVisitor","IsoEncoder","Utf8Encoder","VersionsCodewordsInformation","DataModeInstances","terminator","NUMERIC","ALPHA_NUMERIC","BYTE","powersOfTwo","powersOfTwoResult","irregularAlignmentPatternsStartDistance","finderPattern","alignmentPattern","errorCorrectionPatterns","L","M","Q","H","formatMaskPattern","formatGeneratorPolynomial","versionGeneratorPolynomial","paddingCodewords","finderPatternValue","maskPatternConditions","row","column","Math","floor","numberRegex","alphaPattern","alphaExclusiveSet","alphaRegex","RegExp","alphaNumericRegex","byteRegex","initMinNumericBeforeAlpha","initMinNumericBeforeByte","initMinAlphaBeforeByte","minNumericBeforeAlpha","minNumericBeforeByte","minAlphaBeforeByte","generatorPolynomials","fillFunctionCell","matrices","bit","x","y","i","length","fillDataCell","parseInt","fillData","blocks","cellVisitor","block","codewordIdx","cell","blockIdx","j","getNextCell","charAt","splice","getNextRemainderCell","padDataString","initialDataString","totalDataCodewords","dataBitsCount","terminatorIndex","paddingCodewordIndex","dataString","Array","join","generatePowersOfTwo","result","power","xorPolynomials","idx","multiplyPolynomials","undefined","generateGeneratorPolynomials","maxErrorCorrectionCodeWordsCount","firstPolynomial","secondPolynomial","multiplyByConstant","polynomial","generateErrorCodewords","data","errorCodewordsCount","generator","concat","generatorPolynomial","steps","errorCodewords","divisor","getBlocks","dataStream","versionCodewordsInformation","codewordStart","dataBlocks","errorBlocks","dataBlock","versionGroups","groups","blockCodewordsCount","groupBlocksCount","messagePolynomial","codeword","groupIdx","substring","push","errorCodewordsPerBlock","chooseMode","str","previousMode","numeric","exec","numericMatch","alpha","alphaMatch","alphaNumeric","alphaNumericMatch","mode","modeString","test","getModes","inputString","modes","substr","nextMode","getDataCodewordsCount","getStringBitsLength","ceil","getVersion","dataCodewordsCount","errorCorrectionLevel","version","getDataString","encode","encodeFormatInformation","format","formatNumber","encodedString","encodeBCH","value","codeLength","generatorNumber","polynomialLength","valueNumber","valueString","dividePolynomials","numberX","numberY","yLength","toString","xLength","getNumberAt","initMatrices","modules","addFormatInformation","formatString","matrix","encodeVersionInformation","addVersionInformation","x1","y1","x2","y2","quotient","mod","addCentricPattern","pattern","size","addFinderSeparator","direction","nextX","nextY","addFinderPatterns","addAlignmentPatterns","pointsCount","points","startDistance","distance","addTimingFunctions","scoreMaskMatrixes","scores","previousBits","darkModules","patterns","adjacentSameBits","modulesLength","rowIndex","columnIndex","matrixIndex","scoreFinderPatternOccurance","scoreAdjacentSameBits","total","minIdx","min","Number","MAX_VALUE","calculateDarkModulesRatioScore","rowColumn","adjacentBits","percent","mod5","previous","abs","next","score","createQRCodeDataEncoder","encoding","toLowerCase","indexOf","encodeData","encoder","encodingResult","getEncodingResult","versionInformation","optimalMatrix"],"mappings":"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","sourcesContent":["import {\n    toBitsString,\n    toDecimal\n} from '../utils';\nimport { FreeCellVisitor } from './free-cell-visitor';\nimport { IsoEncoder } from './encoders/iso-encoder';\nimport { Utf8Encoder } from './encoders/utf8-encoder';\nimport { VersionsCodewordsInformation } from './version-codewords';\nimport { DataModeInstances } from './data-modes/data-mode-instances';\n\nvar terminator = \"0000\",\n    NUMERIC = \"numeric\",\n    ALPHA_NUMERIC = \"alphanumeric\",\n    BYTE = \"byte\",\n    powersOfTwo = { \"1\": 0 },\n    powersOfTwoResult = { \"0\": 1 },\n    irregularAlignmentPatternsStartDistance = {\n        15: 20, 16: 20, 18: 24, 19: 24, 22: 20,\n        24: 22, 26: 24, 28: 20, 30: 20, 31: 24,\n        32: 28, 33: 24, 36: 18, 37: 22, 39: 20, 40: 24\n    },\n    finderPattern = [1, 0, 1, 1, 1],\n    alignmentPattern = [1, 0, 1],\n    errorCorrectionPatterns = { L: \"01\", M: \"00\", Q: \"11\", H: \"10\" },\n    formatMaskPattern = \"101010000010010\",\n    formatGeneratorPolynomial = \"10100110111\",\n    versionGeneratorPolynomial = \"1111100100101\",\n    paddingCodewords = [\"11101100\", \"00010001\"],\n    finderPatternValue = 93,\n    /* eslint-disable arrow-body-style */\n    /* eslint-disable no-unused-vars */\n    maskPatternConditions = [\n        function (row, column) { return (row + column) % 2 === 0; },\n        function (row, column) { return row % 2 === 0; },\n        function (row, column) { return column % 3 === 0; },\n        function (row, column) { return (row + column) % 3 === 0; },\n        function (row, column) { return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0; },\n        function (row, column) { return ((row * column) % 2) + ((row * column) % 3) === 0; },\n        function (row, column) { return (((row * column) % 2) + ((row * column) % 3)) % 2 === 0; },\n        function (row, column) { return (((row + column) % 2) + ((row * column) % 3)) % 2 === 0; }\n    ],\n    /* eslint-enable no-unused-vars */\n    /* eslint-enable arrow-body-style */\n    numberRegex = /^\\d+/,\n    alphaPattern = \"A-Z0-9 $%*+./:-\",\n    alphaExclusiveSet = \"A-Z $%*+./:-\",\n    alphaRegex = new RegExp(\"^[\" + alphaExclusiveSet + \"]+\"),\n    alphaNumericRegex = new RegExp(\"^[\" + alphaPattern + \"]+\"),\n    byteRegex = new RegExp(\"^[^\" + alphaPattern + \"]+\"),\n    initMinNumericBeforeAlpha = 8,\n    initMinNumericBeforeByte = 5,\n    initMinAlphaBeforeByte = 8,\n    minNumericBeforeAlpha = 17,\n    minNumericBeforeByte = 9,\n    minAlphaBeforeByte = 16;\n\nexport var generatorPolynomials = [[1, 0], [1, 25, 0]];\n\nexport function fillFunctionCell(matrices, bit, x, y) {\n    for (var i = 0; i < matrices.length; i++) {\n        matrices[i][x][y] = bit;\n    }\n}\n\nexport function fillDataCell(matrices, bit, x, y) {\n    for (var i = 0; i < maskPatternConditions.length; i++) {\n        matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);\n    }\n}\n\nexport function fillData(matrices, blocks) {\n    var cellVisitor = new FreeCellVisitor(matrices[0]),\n        block,\n        codewordIdx,\n        cell;\n\n    for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {\n        block = blocks[blockIdx];\n        codewordIdx = 0;\n\n        while (block.length > 0) {\n            for (var i = 0; i < block.length; i++) {\n                for (var j = 0; j < 8; j++) {\n                    cell = cellVisitor.getNextCell();\n                    fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);\n                }\n            }\n\n            codewordIdx++;\n\n            while (block[0] && codewordIdx === block[0].length) {\n                block.splice(0, 1);\n            }\n        }\n    }\n\n    while ((cell = cellVisitor.getNextRemainderCell())) {\n        fillDataCell(matrices, 0, cell.row, cell.column);\n    }\n}\n\nexport function padDataString(initialDataString, totalDataCodewords) {\n    var dataBitsCount = totalDataCodewords * 8,\n        terminatorIndex = 0,\n        paddingCodewordIndex = 0;\n    var dataString = initialDataString;\n\n    while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {\n        dataString += terminator.charAt(terminatorIndex++);\n    }\n\n    if (dataString.length % 8 !== 0) {\n        dataString += new Array(9 - dataString.length % 8).join(\"0\");\n    }\n\n    while (dataString.length < dataBitsCount) {\n        dataString += paddingCodewords[paddingCodewordIndex];\n        paddingCodewordIndex ^= 1;\n    }\n\n    return dataString;\n}\n\nexport function generatePowersOfTwo() {\n    var result;\n    var power;\n\n    for (power = 1; power < 255; power++) {\n        result = powersOfTwoResult[power - 1] * 2;\n        if (result > 255) {\n            result = result ^ 285;\n        }\n\n        powersOfTwoResult[power] = result;\n        powersOfTwo[result] = power;\n    }\n\n    result = (powersOfTwoResult[power - 1] * 2) ^ 285;\n    powersOfTwoResult[power] = result;\n    powersOfTwoResult[-1] = 0;\n}\n\nexport function xorPolynomials(x, y) {\n    var result = [],\n        idx = x.length - 2;\n\n    for (var i = idx; i >= 0; i--) {\n        result[i] = x[i] ^ y[i];\n    }\n\n    return result;\n}\n\nexport function multiplyPolynomials(x, y) {\n    var result = [];\n\n    for (var i = 0; i < x.length; i++) {\n        for (var j = 0; j < y.length; j++) {\n            if (result[i + j] === undefined) {\n                result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;\n            } else {\n                result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];\n            }\n        }\n    }\n\n    return result;\n}\n\nexport function generateGeneratorPolynomials() {\n    var maxErrorCorrectionCodeWordsCount = 68;\n\n    for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {\n        var firstPolynomial = generatorPolynomials[idx - 1],\n            secondPolynomial = [idx, 0];\n\n        generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);\n    }\n}\n\n//possibly generate on demand\ngeneratePowersOfTwo();\ngenerateGeneratorPolynomials();\n\nexport function multiplyByConstant(polynomial, power) {\n    var result = [],\n        idx = polynomial.length - 1;\n\n    do {\n        result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];\n        idx--;\n    }\n    while (polynomial[idx] !== undefined);\n\n    return result;\n}\n\nexport function generateErrorCodewords(data, errorCodewordsCount) {\n    var generator = generatorPolynomials[errorCodewordsCount - 1],\n        result = new Array(errorCodewordsCount).concat(data),\n        generatorPolynomial = new Array(result.length - generator.length).concat(generator),\n        steps = data.length,\n        errorCodewords = [],\n        divisor,\n        idx;\n\n    for (idx = 0; idx < steps; idx++) {\n        divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);\n        generatorPolynomial.splice(0, 1);\n\n        result = xorPolynomials(divisor, result);\n    }\n\n    for (idx = result.length - 1; idx >= 0; idx--) {\n        errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);\n    }\n\n    return errorCodewords;\n}\n\nexport function getBlocks(dataStream, versionCodewordsInformation) {\n    var codewordStart = 0,\n        dataBlocks = [],\n        errorBlocks = [],\n        dataBlock,\n        versionGroups = versionCodewordsInformation.groups,\n        blockCodewordsCount,\n        groupBlocksCount,\n        messagePolynomial,\n        codeword;\n\n    for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {\n        groupBlocksCount = versionGroups[groupIdx][0];\n\n        for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {\n            blockCodewordsCount = versionGroups[groupIdx][1];\n            dataBlock = [];\n            messagePolynomial = [];\n\n            for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {\n                codeword = dataStream.substring(codewordStart, codewordStart + 8);\n                dataBlock.push(codeword);\n                messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);\n                codewordStart += 8;\n            }\n\n            dataBlocks.push(dataBlock);\n            errorBlocks.push(generateErrorCodewords(messagePolynomial,\n                versionCodewordsInformation.errorCodewordsPerBlock));\n        }\n    }\n    return [dataBlocks, errorBlocks];\n}\n\nexport function chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode) {\n    var numeric = numberRegex.exec(str),\n        numericMatch = numeric ? numeric[0] : \"\",\n        alpha = alphaRegex.exec(str),\n        alphaMatch = alpha ? alpha[0] : \"\",\n        alphaNumeric = alphaNumericRegex.exec(str),\n        alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : \"\",\n        mode,\n        modeString;\n\n    if (numericMatch &&\n        (numericMatch.length >= minNumericBeforeAlpha || str.length === numericMatch.length ||\n        (numericMatch.length >= minNumericBeforeByte && !alphaNumericRegex.test(str.charAt(numericMatch.length))))) {\n        mode = NUMERIC;\n        modeString = numericMatch;\n    } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length ||\n        alphaNumericMatch.length >= minAlphaBeforeByte || previousMode === ALPHA_NUMERIC)) {\n        mode = ALPHA_NUMERIC;\n        modeString = numericMatch || alphaMatch;\n    } else {\n        mode = BYTE;\n\n        if (alphaNumericMatch) {\n            modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];\n        } else {\n            modeString = byteRegex.exec(str)[0];\n        }\n    }\n\n    return {\n        mode: mode,\n        modeString: modeString\n    };\n}\n\nexport function getModes(inputString) {\n    var modes = [],\n        previousMode,\n        idx = 0;\n    var str = inputString;\n\n    modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));\n    previousMode = modes[0].mode;\n    str = str.substr(modes[0].modeString.length);\n\n    while (str.length > 0) {\n        var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);\n\n        if (nextMode.mode !== previousMode) {\n            previousMode = nextMode.mode;\n            modes.push(nextMode);\n            idx++;\n        } else {\n            modes[idx].modeString += nextMode.modeString;\n        }\n\n        str = str.substr(nextMode.modeString.length);\n    }\n\n    return modes;\n}\n\nexport function getDataCodewordsCount(modes) {\n    var length = 0,\n        mode;\n\n    for (var i = 0; i < modes.length; i++) {\n        mode = DataModeInstances[modes[i].mode];\n        length += mode.getStringBitsLength(modes[i].modeString.length);\n    }\n\n    return Math.ceil(length / 8);\n}\n\nexport function getVersion(dataCodewordsCount, errorCorrectionLevel) {\n    var x = 0,\n        y = VersionsCodewordsInformation.length - 1,\n        version = Math.floor(VersionsCodewordsInformation.length / 2);\n\n    do {\n        if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {\n            y = version;\n        } else {\n            x = version;\n        }\n\n        version = x + Math.floor((y - x) / 2);\n    } while (y - x > 1);\n\n    if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {\n        return version + 1;\n    }\n\n    return y + 1;\n}\n\nexport function getDataString(modes, version) {\n    var dataString = \"\",\n        mode;\n\n    for (var i = 0; i < modes.length; i++) {\n        mode = DataModeInstances[modes[i].mode];\n        dataString += mode.encode(modes[i].modeString, version);\n    }\n\n    return dataString;\n}\n\n//fix case all zeros\nexport function encodeFormatInformation(format) {\n    var formatNumber = toDecimal(format),\n        encodedString,\n        result = \"\";\n\n    if (formatNumber === 0) {\n        return \"101010000010010\";\n    }\n\n    encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);\n\n    for (var i = 0; i < encodedString.length; i++) {\n        result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);\n    }\n\n    return result;\n}\n\nexport function encodeBCH(value, generatorPolynomial, codeLength) {\n    var generatorNumber = toDecimal(generatorPolynomial),\n        polynomialLength = generatorPolynomial.length - 1,\n        valueNumber = value << polynomialLength,\n        length = codeLength - polynomialLength,\n        valueString = toBitsString(value, length),\n        result = dividePolynomials(valueNumber, generatorNumber);\n\n    result = valueString + toBitsString(result, polynomialLength);\n\n    return result;\n}\n\nexport function dividePolynomials(numberX, numberY) {\n    var yLength = numberY.toString(2).length,\n        xLength = numberX.toString(2).length;\n    var x = numberX;\n\n    do {\n        x ^= numberY << xLength - yLength;\n        xLength = x.toString(2).length;\n    }\n    while (xLength >= yLength);\n\n    return x;\n}\n\nexport function getNumberAt(str, idx) {\n    return parseInt(str.charAt(idx), 10);\n}\n\nexport function initMatrices(version) {\n    var matrices = [],\n        modules = 17 + 4 * version;\n\n    for (var i = 0; i < maskPatternConditions.length; i++) {\n        matrices[i] = new Array(modules);\n\n        for (var j = 0; j < modules; j++) {\n            matrices[i][j] = new Array(modules);\n        }\n    }\n\n    return matrices;\n}\n\nexport function addFormatInformation(matrices, formatString) {\n    var matrix = matrices[0],\n        x,\n        y,\n        idx = 0,\n        length = formatString.length;\n\n    for (x = 0, y = 8; x <= 8; x++) {\n        if (x !== 6) {\n            fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n        }\n    }\n\n    for (x = 8, y = 7; y >= 0; y--) {\n        if (y !== 6) {\n            fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n        }\n    }\n\n    idx = 0;\n\n    for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {\n        fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n\n    fillFunctionCell(matrices, 1, matrix.length - 8, 8);\n\n    for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {\n        fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n}\n\nexport function encodeVersionInformation(version) {\n    return encodeBCH(version, versionGeneratorPolynomial, 18);\n}\n\nexport function addVersionInformation(matrices, dataString) {\n    var matrix = matrices[0],\n        modules = matrix.length,\n        x1 = 0,\n        y1 = modules - 11,\n        x2 = modules - 11,\n        y2 = 0,\n        quotient,\n        mod,\n        value;\n\n    for (var idx = 0; idx < dataString.length; idx++) {\n        quotient = Math.floor(idx / 3);\n        mod = idx % 3;\n        value = getNumberAt(dataString, dataString.length - idx - 1);\n\n        fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);\n        fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);\n    }\n}\n\nexport function addCentricPattern(matrices, pattern, x, y) {\n    var size = pattern.length + 2,\n        length = pattern.length + 1,\n        value;\n\n    for (var i = 0; i < pattern.length; i++) {\n        for (var j = i; j < size - i; j++) {\n            value = pattern[i];\n\n            fillFunctionCell(matrices, value, x + j, y + i);\n            fillFunctionCell(matrices, value, x + i, y + j);\n            fillFunctionCell(matrices, value, x + length - j, y + length - i);\n            fillFunctionCell(matrices, value, x + length - i, y + length - j);\n        }\n    }\n}\n\nexport function addFinderSeparator(matrices, direction, x, y) {\n    var nextX = x,\n        nextY = y,\n        matrix = matrices[0];\n\n    do {\n        fillFunctionCell(matrices, 0, nextX, y);\n        fillFunctionCell(matrices, 0, x, nextY);\n        nextX += direction[0];\n        nextY += direction[1];\n    }\n    while (nextX >= 0 && nextX < matrix.length);\n}\n\nexport function addFinderPatterns(matrices) {\n    var modules = matrices[0].length;\n\n    addCentricPattern(matrices, finderPattern, 0, 0);\n    addFinderSeparator(matrices, [-1, -1], 7, 7);\n    addCentricPattern(matrices, finderPattern, modules - 7, 0);\n    addFinderSeparator(matrices, [1, -1], modules - 8, 7);\n    addCentricPattern(matrices, finderPattern, 0, modules - 7);\n    addFinderSeparator(matrices, [-1, 1], 7, modules - 8);\n}\n\nexport function addAlignmentPatterns(matrices, version) {\n    if (version < 2) {\n        return;\n    }\n\n    var matrix = matrices[0],\n        modules = matrix.length,\n        pointsCount = Math.floor(version / 7),\n        points = [6],\n        startDistance,\n        distance,\n        idx = 0;\n\n    if ((startDistance = irregularAlignmentPatternsStartDistance[version])) {\n        distance = (modules - 13 - startDistance) / pointsCount;\n    } else {\n        startDistance = distance = (modules - 13) / (pointsCount + 1);\n    }\n\n    points.push(points[idx++] + startDistance);\n\n    while ((points[idx] + distance) < modules) {\n        points.push(points[idx++] + distance);\n    }\n\n    for (var i = 0; i < points.length; i++) {\n        for (var j = 0; j < points.length; j++) {\n            if (matrix[points[i]][points[j]] === undefined) {\n                addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);\n            }\n        }\n    }\n}\n\nexport function addTimingFunctions(matrices) {\n    var row = 6,\n        column = 6,\n        value = 1,\n        modules = matrices[0].length;\n\n    for (var i = 8; i < modules - 8; i++) {\n        fillFunctionCell(matrices, value, row, i);\n        fillFunctionCell(matrices, value, i, column);\n        value ^= 1;\n    }\n}\n\nexport function scoreMaskMatrixes(matrices) {\n    var scores = [],\n        previousBits = [],\n        darkModules = [],\n        patterns = [],\n        adjacentSameBits = [],\n        matrix,\n        i,\n        row = 0,\n        column = 1,\n        modulesLength = matrices[0].length;\n\n    for (i = 0; i < matrices.length; i++) {\n        scores[i] = 0;\n        darkModules[i] = 0;\n        adjacentSameBits[i] = [0, 0];\n        patterns[i] = [0, 0];\n        previousBits[i] = [];\n    }\n\n    for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {\n        for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {\n            for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {\n                matrix = matrices[matrixIndex];\n                darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);\n\n                if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] &&\n                    rowIndex + 1 < modulesLength &&\n                    columnIndex - 1 >= 0 &&\n                    matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] &&\n                    matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {\n                    scores[matrixIndex] += 3;\n                }\n\n                scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);\n                scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);\n                scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);\n                scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);\n            }\n        }\n    }\n\n    var total = modulesLength * modulesLength,\n        minIdx,\n        min = Number.MAX_VALUE;\n\n    for (i = 0; i < scores.length; i++) {\n        scores[i] += calculateDarkModulesRatioScore(darkModules[i], total);\n\n        if (scores[i] < min) {\n            min = scores[i];\n            minIdx = i;\n        }\n    }\n\n    return minIdx;\n}\n\nexport function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {\n    patterns[idx][rowColumn] = ((patterns[idx][rowColumn] << 1) ^ bit) % 128;\n\n    if (patterns[idx][rowColumn] === finderPatternValue) {\n        scores[idx] += 40;\n    }\n}\n\nexport function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {\n    if (previousBits[idx][rowColumn] === bit) {\n        adjacentBits[idx][rowColumn]++;\n    } else {\n        previousBits[idx][rowColumn] = bit;\n\n        if (adjacentBits[idx][rowColumn] >= 5) {\n            scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;\n        }\n\n        adjacentBits[idx][rowColumn] = 1;\n    }\n}\n\nexport function calculateDarkModulesRatioScore(darkModules, total) {\n    var percent = Math.floor((darkModules / total) * 100),\n        mod5 = percent % 5,\n        previous = Math.abs(percent - mod5 - 50),\n        next = Math.abs(percent + 5 - mod5 - 50),\n        score = 10 * Math.min(previous / 5, next / 5);\n\n    return score;\n}\n\nexport function createQRCodeDataEncoder(encoding) {\n    if (encoding && encoding.toLowerCase().indexOf(\"utf_8\") >= 0) {\n        return new Utf8Encoder();\n    }\n\n    return new IsoEncoder();\n}\n\nexport function encodeData(inputString, errorCorrectionLevel, encoding) {\n    var encoder = createQRCodeDataEncoder(encoding),\n        encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel),\n        version = encodingResult.version,\n        versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel],\n        dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords),\n        blocks = getBlocks(dataString, versionInformation),\n        matrices = initMatrices(version);\n\n    addFinderPatterns(matrices);\n    addAlignmentPatterns(matrices, version);\n    addTimingFunctions(matrices);\n\n    if (version >= 7) {\n        addVersionInformation(matrices, toBitsString(0, 18));\n    }\n\n    addFormatInformation(matrices, toBitsString(0, 15));\n    fillData(matrices, blocks);\n\n    var minIdx = scoreMaskMatrixes(matrices),\n        optimalMatrix = matrices[minIdx];\n\n    if (version >= 7) {\n        addVersionInformation([optimalMatrix], encodeVersionInformation(version));\n    }\n\n    var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);\n    addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));\n\n    return optimalMatrix;\n}\n"]},"metadata":{},"sourceType":"module"}