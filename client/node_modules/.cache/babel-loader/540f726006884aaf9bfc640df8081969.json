{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nvar Axis = function (ChartElement) {\n  function Axis(options, chartService) {\n    if (chartService === void 0) chartService = new ChartService();\n    ChartElement.call(this, options);\n    this.chartService = chartService;\n\n    if (!this.options.visible) {\n      this.options = deepExtend({}, this.options, {\n        labels: {\n          visible: false\n        },\n        line: {\n          visible: false\n        },\n        margin: 0,\n        majorTickSize: 0,\n        minorTickSize: 0\n      });\n    }\n\n    this.options.minorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.minorTickType !== NONE\n    }, this.options.minorTicks, {\n      size: this.options.minorTickSize,\n      align: this.options.minorTickType\n    });\n    this.options.majorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.majorTickType !== NONE\n    }, this.options.majorTicks, {\n      size: this.options.majorTickSize,\n      align: this.options.majorTickType\n    });\n    this.initFields();\n\n    if (!this.options._deferLabels) {\n      this.createLabels();\n    }\n\n    this.createTitle();\n    this.createNotes();\n  }\n\n  if (ChartElement) Axis.__proto__ = ChartElement;\n  Axis.prototype = Object.create(ChartElement && ChartElement.prototype);\n  Axis.prototype.constructor = Axis;\n\n  Axis.prototype.initFields = function initFields() {}; // abstract labelsCount(): Number\n  // abstract createAxisLabel(index, options): AxisLabel\n\n\n  Axis.prototype.labelsRange = function labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.labelsCount()\n    };\n  };\n\n  Axis.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {\n    var rotation = labelOptions.rotation;\n\n    if (isObject(rotation)) {\n      labelOptions.alignRotation = rotation.align;\n      labelOptions.rotation = rotation.angle;\n    }\n  };\n\n  Axis.prototype.createLabels = function createLabels() {\n    var this$1 = this;\n    var options = this.options;\n    var align = options.vertical ? RIGHT : CENTER;\n    var labelOptions = deepExtend({}, options.labels, {\n      align: align,\n      zIndex: options.zIndex\n    });\n    var step = Math.max(1, labelOptions.step);\n    this.clearLabels();\n\n    if (labelOptions.visible) {\n      this.normalizeLabelRotation(labelOptions);\n\n      if (labelOptions.rotation === \"auto\") {\n        labelOptions.rotation = 0;\n        options.autoRotateLabels = true;\n      }\n\n      var range = this.labelsRange();\n\n      for (var idx = range.min; idx < range.max; idx += step) {\n        var labelContext = {\n          index: idx,\n          count: range.max\n        };\n        var label = this$1.createAxisLabel(idx, labelOptions, labelContext);\n\n        if (label) {\n          this$1.append(label);\n          this$1.labels.push(label);\n        }\n      }\n    }\n  };\n\n  Axis.prototype.clearLabels = function clearLabels() {\n    this.children = grep(this.children, function (child) {\n      return !(child instanceof AxisLabel);\n    });\n    this.labels = [];\n  };\n\n  Axis.prototype.clearTitle = function clearTitle() {\n    var this$1 = this;\n\n    if (this.title) {\n      this.children = grep(this.children, function (child) {\n        return child !== this$1.title;\n      });\n      this.title = undefined;\n    }\n  };\n\n  Axis.prototype.clear = function clear() {\n    this.clearLabels();\n    this.clearTitle();\n  };\n\n  Axis.prototype.lineBox = function lineBox() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var axisX = mirror ? box.x1 : box.x2;\n    var axisY = mirror ? box.y2 : box.y1;\n    var lineWidth = options.line.width || 0;\n    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n  };\n\n  Axis.prototype.createTitle = function createTitle() {\n    var options = this.options;\n    var titleOptions = deepExtend({\n      rotation: options.vertical ? -90 : 0,\n      text: \"\",\n      zIndex: 1,\n      visualSize: true\n    }, options.title);\n\n    if (titleOptions.visible && titleOptions.text) {\n      var title = new TextBox(titleOptions.text, titleOptions);\n      this.append(title);\n      this.title = title;\n    }\n  };\n\n  Axis.prototype.createNotes = function createNotes() {\n    var this$1 = this;\n    var options = this.options;\n    var notes = options.notes;\n    var items = notes.data || [];\n    this.notes = [];\n\n    for (var i = 0; i < items.length; i++) {\n      var item = deepExtend({}, notes, items[i]);\n      item.value = this$1.parseNoteValue(item.value);\n      var note = new Note({\n        value: item.value,\n        text: item.label.text,\n        dataItem: item\n      }, item, this$1.chartService);\n\n      if (note.options.visible) {\n        if (defined(note.options.position)) {\n          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        } else {\n          if (options.vertical) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        }\n\n        this$1.append(note);\n        this$1.notes.push(note);\n      }\n    }\n  };\n\n  Axis.prototype.parseNoteValue = function parseNoteValue(value) {\n    return value;\n  };\n\n  Axis.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n    this.createPlotBands();\n  };\n\n  Axis.prototype.createVisual = function createVisual() {\n    ChartElement.prototype.createVisual.call(this);\n    this.createBackground();\n    this.createLine();\n  };\n\n  Axis.prototype.gridLinesVisual = function gridLinesVisual() {\n    var gridLines = this._gridLines;\n\n    if (!gridLines) {\n      gridLines = this._gridLines = new draw.Group({\n        zIndex: -2\n      });\n      this.appendVisual(this._gridLines);\n    }\n\n    return gridLines;\n  };\n\n  Axis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var mirror = options.labels.mirror;\n    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: options.vertical\n    };\n\n    function render(tickPositions, tickOptions, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, tickOptions.step);\n\n      if (tickOptions.visible) {\n        for (var i = tickOptions.skip; i < count; i += step) {\n          if (defined(skipUnit) && i % skipUnit === 0) {\n            continue;\n          }\n\n          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n          tickLineOptions.position = tickPositions[i];\n          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), options.majorTicks);\n    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n  };\n\n  Axis.prototype.createLine = function createLine() {\n    var options = this.options;\n    var line = options.line;\n    var lineBox = this.lineBox();\n\n    if (line.width > 0 && line.visible) {\n      var path = new draw.Path({\n        stroke: {\n          width: line.width,\n          color: line.color,\n          dashType: line.dashType\n        }\n        /* TODO\n        zIndex: line.zIndex,\n        */\n\n      });\n      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n\n      if (options._alignLines) {\n        alignPathToPixel(path);\n      }\n\n      var group = this._lineGroup = new draw.Group();\n      group.append(path);\n      this.visual.append(group);\n      this.createTicks(group);\n    }\n  };\n\n  Axis.prototype.getActualTickSize = function getActualTickSize() {\n    var options = this.options;\n    var tickSize = 0;\n\n    if (options.majorTicks.visible && options.minorTicks.visible) {\n      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n    } else if (options.majorTicks.visible) {\n      tickSize = options.majorTicks.size;\n    } else if (options.minorTicks.visible) {\n      tickSize = options.minorTicks.size;\n    }\n\n    return tickSize;\n  };\n\n  Axis.prototype.createBackground = function createBackground() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var background = options.background;\n\n    if (background) {\n      this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n        fill: {\n          color: background\n        },\n        stroke: null\n      });\n      this.visual.append(this._backgroundPath);\n    }\n  };\n\n  Axis.prototype.createPlotBands = function createPlotBands() {\n    var this$1 = this;\n    var options = this.options;\n    var plotBands = options.plotBands || [];\n    var vertical = options.vertical;\n    var plotArea = this.plotArea;\n\n    if (plotBands.length === 0) {\n      return;\n    }\n\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    var altAxis = grep(this.pane.axes, function (axis) {\n      return axis.options.vertical !== this$1.options.vertical;\n    })[0];\n\n    for (var idx = 0; idx < plotBands.length; idx++) {\n      var item = plotBands[idx];\n      var slotX = void 0,\n          slotY = void 0;\n      var labelOptions = item.label;\n      var label = void 0;\n\n      if (vertical) {\n        slotX = (altAxis || plotArea.axisX).lineBox();\n        slotY = this$1.getSlot(item.from, item.to, true);\n      } else {\n        slotX = this$1.getSlot(item.from, item.to, true);\n        slotY = (altAxis || plotArea.axisY).lineBox();\n      }\n\n      if (labelOptions) {\n        labelOptions.vAlign = labelOptions.position || LEFT;\n        label = this$1.createPlotBandLabel(labelOptions, item, new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2));\n      }\n\n      if (slotX.width() !== 0 && slotY.height() !== 0) {\n        var bandRect = new geom.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n        var path = draw.Path.fromRect(bandRect, {\n          fill: {\n            color: item.color,\n            opacity: item.opacity\n          },\n          stroke: null\n        });\n        group.append(path);\n\n        if (label) {\n          group.append(label);\n        }\n      }\n    }\n\n    this.appendVisual(group);\n  };\n\n  Axis.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {\n    if (label.visible === false) {\n      return null;\n    }\n\n    var text = label.text;\n    var textbox;\n\n    if (defined(label) && label.visible) {\n      var labelTemplate = getTemplate(label);\n\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: text,\n          item: item\n        });\n      } else if (label.format) {\n        text = this.chartService.format.auto(label.format, text);\n      }\n\n      if (!label.color) {\n        label.color = this.options.labels.color;\n      }\n    }\n\n    textbox = new TextBox(text, label);\n    textbox.reflow(box);\n    textbox.renderVisual();\n    return textbox.visual;\n  };\n\n  Axis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var minorUnit = options.minorUnit;\n    var vertical = options.vertical;\n    var axisLineVisible = altAxis.options.line.visible;\n    var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n    var lineBox = altAxis.lineBox();\n    var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n\n    function render(tickPositions, gridLine, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, gridLine.step);\n\n      if (gridLine.visible) {\n        for (var i = gridLine.skip; i < count; i += step) {\n          var pos = round(tickPositions[i]);\n\n          if (!inArray(pos, majorTicks)) {\n            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n              lineOptions.position = pos;\n              container.append(createAxisGridLine(lineOptions, gridLine));\n              majorTicks.push(pos);\n            }\n          }\n        }\n      }\n    }\n\n    render(this.getMajorTickPositions(), majorGridLines);\n    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n    return container.children;\n  };\n\n  Axis.prototype.reflow = function reflow(box) {\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var title = ref.title;\n    var vertical = options.vertical;\n    var count = labels.length;\n    var sizeFn = vertical ? WIDTH : HEIGHT;\n    var titleSize = title ? title.box[sizeFn]() : 0;\n    var space = this.getActualTickSize() + options.margin + titleSize;\n    var rootBox = (this.getRoot() || {}).box || box;\n    var boxSize = rootBox[sizeFn]();\n    var maxLabelSize = 0;\n\n    for (var i = 0; i < count; i++) {\n      var labelSize = labels[i].box[sizeFn]();\n\n      if (labelSize + space <= boxSize) {\n        maxLabelSize = Math.max(maxLabelSize, labelSize);\n      }\n    }\n\n    if (vertical) {\n      this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n    } else {\n      this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n    }\n\n    this.arrangeTitle();\n    this.arrangeLabels();\n    this.arrangeNotes();\n  };\n\n  Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getMajorTickPositions();\n  };\n\n  Axis.prototype.labelTickIndex = function labelTickIndex(label) {\n    return label.index;\n  };\n\n  Axis.prototype.arrangeLabels = function arrangeLabels() {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var tickPositions = this.getLabelsTickPositions();\n\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var labelSize = vertical ? label.box.height() : label.box.width();\n      var firstTickPosition = tickPositions[tickIx];\n      var nextTickPosition = tickPositions[tickIx + 1];\n      var positionStart = void 0,\n          positionEnd = void 0;\n\n      if (vertical) {\n        if (labelsBetweenTicks) {\n          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n          positionStart = middle - labelSize / 2;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n        }\n\n        positionEnd = positionStart;\n      } else {\n        if (labelsBetweenTicks) {\n          positionStart = firstTickPosition;\n          positionEnd = nextTickPosition;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n          positionEnd = positionStart + labelSize;\n        }\n      }\n\n      this$1.positionLabel(label, mirror, positionStart, positionEnd);\n    }\n  };\n\n  Axis.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {\n    if (positionEnd === void 0) positionEnd = positionStart;\n    var options = this.options;\n    var vertical = options.vertical;\n    var lineBox = this.lineBox();\n    var labelOffset = this.getActualTickSize() + options.margin;\n    var labelBox;\n\n    if (vertical) {\n      var labelX = lineBox.x2;\n\n      if (mirror) {\n        labelX += labelOffset;\n        label.options.rotationOrigin = LEFT;\n      } else {\n        labelX -= labelOffset + label.box.width();\n        label.options.rotationOrigin = RIGHT;\n      }\n\n      labelBox = label.box.move(labelX, positionStart);\n    } else {\n      var labelY = lineBox.y1;\n\n      if (mirror) {\n        labelY -= labelOffset + label.box.height();\n        label.options.rotationOrigin = BOTTOM;\n      } else {\n        labelY += labelOffset;\n        label.options.rotationOrigin = TOP;\n      }\n\n      labelBox = new Box(positionStart, labelY, positionEnd, labelY + label.box.height());\n    }\n\n    label.reflow(labelBox);\n  };\n\n  Axis.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {\n    if (labelBox.width() < slotWidth) {\n      return 0;\n    }\n\n    if (labelBox.height() > slotWidth) {\n      return -90;\n    }\n\n    return -45;\n  };\n\n  Axis.prototype.autoRotateLabels = function autoRotateLabels() {\n    var this$1 = this;\n\n    if (!this.options.autoRotateLabels || this.options.vertical) {\n      return false;\n    }\n\n    var tickPositions = this.getMajorTickPositions();\n    var labels = this.labels;\n    var limit = Math.min(labels.length, tickPositions.length - 1);\n    var angle = 0;\n\n    for (var idx = 0; idx < limit; idx++) {\n      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n      var labelBox = labels[idx].box;\n      var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);\n\n      if (labelAngle !== 0) {\n        angle = labelAngle;\n      }\n\n      if (angle === -90) {\n        break;\n      }\n    }\n\n    if (angle !== 0) {\n      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n        labels[idx$1].options.rotation = angle;\n        labels[idx$1].reflow(new Box());\n      }\n\n      return true;\n    }\n  };\n\n  Axis.prototype.arrangeTitle = function arrangeTitle() {\n    var ref = this;\n    var options = ref.options;\n    var title = ref.title;\n    var mirror = options.labels.mirror;\n    var vertical = options.vertical;\n\n    if (title) {\n      if (vertical) {\n        title.options.align = mirror ? RIGHT : LEFT;\n        title.options.vAlign = title.options.position;\n      } else {\n        title.options.align = title.options.position;\n        title.options.vAlign = mirror ? TOP : BOTTOM;\n      }\n\n      title.reflow(this.box);\n    }\n  };\n\n  Axis.prototype.arrangeNotes = function arrangeNotes() {\n    var this$1 = this;\n\n    for (var idx = 0; idx < this.notes.length; idx++) {\n      var item = this$1.notes[idx];\n      var value = item.options.value;\n      var slot = void 0;\n\n      if (defined(value)) {\n        if (this$1.shouldRenderNote(value)) {\n          item.show();\n        } else {\n          item.hide();\n        }\n\n        slot = this$1.noteSlot(value);\n      } else {\n        item.hide();\n      }\n\n      item.reflow(slot || this$1.lineBox());\n    }\n  };\n\n  Axis.prototype.noteSlot = function noteSlot(value) {\n    return this.getSlot(value);\n  };\n\n  Axis.prototype.alignTo = function alignTo(secondAxis) {\n    var lineBox = secondAxis.lineBox();\n    var vertical = this.options.vertical;\n    var pos = vertical ? Y : X;\n    this.box.snapTo(lineBox, pos);\n\n    if (vertical) {\n      this.box.shrink(0, this.lineBox().height() - lineBox.height());\n    } else {\n      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n    }\n\n    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n  };\n\n  Axis.prototype.axisLabelText = function axisLabelText(value, options, context) {\n    var this$1 = this;\n    var text;\n    var tmpl = getTemplate(options);\n\n    var defaultText = function () {\n      if (!options.format) {\n        return value;\n      }\n\n      return this$1.chartService.format.localeAuto(options.format, [value], options.culture);\n    };\n\n    if (tmpl) {\n      var templateContext = Object.assign({}, context, {\n        get text() {\n          return defaultText();\n        },\n\n        value: value,\n        format: options.format,\n        culture: options.culture\n      });\n      text = tmpl(templateContext);\n    } else {\n      text = defaultText();\n    }\n\n    return text;\n  };\n\n  Axis.prototype.slot = function slot(from, to, limit) {\n    var slot = this.getSlot(from, to, limit);\n\n    if (slot) {\n      return slot.toRect();\n    }\n  };\n\n  Axis.prototype.contentBox = function contentBox() {\n    var box = this.box.clone();\n    var labels = this.labels;\n\n    if (labels.length) {\n      var axis = this.options.vertical ? Y : X;\n\n      if (this.chartService.isPannable(axis)) {\n        var offset = this.maxLabelOffset();\n        box[axis + 1] -= offset.start;\n        box[axis + 2] += offset.end;\n      } else {\n        if (labels[0].options.visible) {\n          box.wrap(labels[0].box);\n        }\n\n        var lastLabel = labels[labels.length - 1];\n\n        if (lastLabel.options.visible) {\n          box.wrap(lastLabel.box);\n        }\n      }\n    }\n\n    return box;\n  };\n\n  Axis.prototype.maxLabelOffset = function maxLabelOffset() {\n    var this$1 = this;\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var tickPositions = this.getLabelsTickPositions();\n    var offsetField = vertical ? Y : X;\n    var labels = this.labels;\n    var startPosition = reverse ? 1 : 0;\n    var endPosition = reverse ? 0 : 1;\n    var maxStartOffset = 0;\n    var maxEndOffset = 0;\n\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var startTick = void 0,\n          endTick = void 0;\n\n      if (labelsBetweenTicks) {\n        startTick = tickPositions[tickIx + startPosition];\n        endTick = tickPositions[tickIx + endPosition];\n      } else {\n        startTick = endTick = tickPositions[tickIx];\n      }\n\n      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n    }\n\n    return {\n      start: maxStartOffset,\n      end: maxEndOffset\n    };\n  };\n\n  Axis.prototype.limitRange = function limitRange(from, to, min, max, offset) {\n    var options = this.options;\n\n    if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n      return null;\n    }\n\n    if (to < min && offset > 0 || max < from && offset < 0) {\n      return {\n        min: from,\n        max: to\n      };\n    }\n\n    var rangeSize = to - from;\n    var minValue = from;\n    var maxValue = to;\n\n    if (from < min && offset < 0) {\n      minValue = limitValue(from, min, max);\n      maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n    } else if (to > max && offset > 0) {\n      maxValue = limitValue(to, min, max);\n      minValue = limitValue(to - rangeSize, min, max - rangeSize);\n    }\n\n    return {\n      min: minValue,\n      max: maxValue\n    };\n  };\n\n  Axis.prototype.valueRange = function valueRange() {\n    return {\n      min: this.seriesMin,\n      max: this.seriesMax\n    };\n  };\n\n  Axis.prototype.lineDir = function lineDir() {\n    /*\n     * Axis line direction:\n     *   * Vertical: up.\n     *   * Horizontal: right.\n     */\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n  };\n\n  Axis.prototype.lineInfo = function lineInfo() {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var lineBox = this.lineBox();\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var axis = vertical ? Y : X;\n    var axisDir = this.lineDir();\n    var startEdge = axisDir === 1 ? 1 : 2;\n    var axisOrigin = axis + startEdge.toString();\n    var lineStart = lineBox[axisOrigin];\n    return {\n      axis: axis,\n      axisOrigin: axisOrigin,\n      axisDir: axisDir,\n      lineBox: lineBox,\n      lineSize: lineSize,\n      lineStart: lineStart\n    };\n  };\n\n  Axis.prototype.pointOffset = function pointOffset(point) {\n    var ref = this.lineInfo();\n    var axis = ref.axis;\n    var axisDir = ref.axisDir;\n    var axisOrigin = ref.axisOrigin;\n    var lineBox = ref.lineBox;\n    var lineSize = ref.lineSize;\n    var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n    var offset = relative / lineSize;\n    return offset;\n  }; // Computes the axis range change (delta) for a given scale factor.\n  // The delta is subtracted from the axis range:\n  //   * delta > 0 reduces the axis range (zoom-in)\n  //   * delta < 0 expands the axis range (zoom-out)\n\n\n  Axis.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {\n    // Scale >= 1 would result in axis range of 0.\n    // Scale <= -1 would reverse the scale direction.\n    var MAX_SCALE = 0.999;\n    var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n    var delta;\n\n    if (scale > 0) {\n      delta = range * Math.min(1, scale);\n    } else {\n      delta = range - range / (1 + scale);\n    }\n\n    return delta;\n  };\n\n  Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks() {\n    return !this.options.justified;\n  }; //add legacy fields to the options that are no longer generated by default\n\n\n  Axis.prototype.prepareUserOptions = function prepareUserOptions() {};\n\n  return Axis;\n}(ChartElement);\n\nsetDefaultOptions(Axis, {\n  labels: {\n    visible: true,\n    rotation: 0,\n    mirror: false,\n    step: 1,\n    skip: 0\n  },\n  line: {\n    width: 1,\n    color: BLACK,\n    visible: true\n  },\n  title: {\n    visible: true,\n    position: CENTER\n  },\n  majorTicks: {\n    align: OUTSIDE,\n    size: 4,\n    skip: 0,\n    step: 1\n  },\n  minorTicks: {\n    align: OUTSIDE,\n    size: 3,\n    skip: 0,\n    step: 1\n  },\n  axisCrossingValue: 0,\n  majorTickType: OUTSIDE,\n  minorTickType: NONE,\n  majorGridLines: {\n    skip: 0,\n    step: 1\n  },\n  minorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK,\n    skip: 0,\n    step: 1\n  },\n  // TODO: Move to line or labels options\n  margin: 5,\n  visible: true,\n  reverse: false,\n  justified: true,\n  notes: {\n    label: {\n      text: \"\"\n    }\n  },\n  _alignLines: true,\n  _deferLabels: false\n});\nexport default Axis;","map":{"version":3,"sources":["/home/meryem/repos/Movie_Trend_Visualizer/client/node_modules/@progress/kendo-charts/dist/es/core/axis.js"],"names":["drawing","draw","geometry","geom","ChartElement","TextBox","AxisLabel","Note","Box","ChartService","createAxisTick","createAxisGridLine","NONE","BLACK","CENTER","TOP","BOTTOM","LEFT","RIGHT","OUTSIDE","X","Y","WIDTH","HEIGHT","alignPathToPixel","deepExtend","getTemplate","grep","defined","isObject","inArray","limitValue","round","setDefaultOptions","Axis","options","chartService","call","visible","labels","line","margin","majorTickSize","minorTickSize","minorTicks","color","width","minorTickType","size","align","majorTicks","majorTickType","initFields","_deferLabels","createLabels","createTitle","createNotes","__proto__","prototype","Object","create","constructor","labelsRange","min","skip","max","labelsCount","normalizeLabelRotation","labelOptions","rotation","alignRotation","angle","this$1","vertical","zIndex","step","Math","clearLabels","autoRotateLabels","range","idx","labelContext","index","count","label","createAxisLabel","append","push","children","child","clearTitle","title","undefined","clear","lineBox","ref","box","mirror","axisX","x1","x2","axisY","y2","y1","lineWidth","titleOptions","text","visualSize","notes","items","data","i","length","item","value","parseNoteValue","note","dataItem","position","reverse","renderVisual","createPlotBands","createVisual","createBackground","createLine","gridLinesVisual","gridLines","_gridLines","Group","appendVisual","createTicks","lineGroup","majorUnit","tickLineOptions","render","tickPositions","tickOptions","skipUnit","tickX","tickY","getMajorTickPositions","getMinorTickPositions","minorUnit","path","Path","stroke","dashType","moveTo","lineTo","_alignLines","group","_lineGroup","visual","getActualTickSize","tickSize","background","_backgroundPath","fromRect","toRect","fill","plotBands","plotArea","_plotbandGroup","altAxis","pane","axes","axis","slotX","slotY","getSlot","from","to","vAlign","createPlotBandLabel","height","bandRect","Rect","opacity","textbox","labelTemplate","format","auto","reflow","createGridLines","minorGridLines","majorGridLines","axisLineVisible","linePos","lineOptions","lineStart","lineEnd","container","gridLine","pos","sizeFn","titleSize","space","rootBox","getRoot","boxSize","maxLabelSize","labelSize","arrangeTitle","arrangeLabels","arrangeNotes","getLabelsTickPositions","labelTickIndex","labelsBetweenTicks","tickIx","firstTickPosition","nextTickPosition","positionStart","positionEnd","middle","positionLabel","labelOffset","labelBox","labelX","rotationOrigin","move","labelY","autoRotateLabelAngle","slotWidth","limit","abs","labelAngle","idx$1","slot","shouldRenderNote","show","hide","noteSlot","alignTo","secondAxis","snapTo","shrink","axisLabelText","context","tmpl","defaultText","localeAuto","culture","templateContext","assign","contentBox","clone","isPannable","offset","maxLabelOffset","start","end","wrap","lastLabel","offsetField","startPosition","endPosition","maxStartOffset","maxEndOffset","startTick","endTick","limitRange","rangeSize","minValue","maxValue","valueRange","seriesMin","seriesMax","lineDir","lineInfo","lineSize","axisDir","startEdge","axisOrigin","toString","pointOffset","point","relative","scaleToDelta","rawScale","MAX_SCALE","scale","delta","justified","prepareUserOptions","axisCrossingValue"],"mappings":"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","sourcesContent":["import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\n\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\n\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\n\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nvar Axis = (function (ChartElement) {\n    function Axis(options, chartService) {\n        if ( chartService === void 0 ) chartService = new ChartService();\n\n        ChartElement.call(this, options);\n\n        this.chartService = chartService;\n\n        if (!this.options.visible) {\n            this.options = deepExtend({}, this.options, {\n                labels: {\n                    visible: false\n                },\n                line: {\n                    visible: false\n                },\n                margin: 0,\n                majorTickSize: 0,\n                minorTickSize: 0\n            });\n        }\n\n        this.options.minorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.minorTickType !== NONE\n        }, this.options.minorTicks, {\n            size: this.options.minorTickSize,\n            align: this.options.minorTickType\n        });\n\n        this.options.majorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.majorTickType !== NONE\n        }, this.options.majorTicks, {\n            size: this.options.majorTickSize,\n            align: this.options.majorTickType\n        });\n\n        this.initFields();\n\n        if (!this.options._deferLabels) {\n            this.createLabels();\n        }\n\n        this.createTitle();\n        this.createNotes();\n    }\n\n    if ( ChartElement ) Axis.__proto__ = ChartElement;\n    Axis.prototype = Object.create( ChartElement && ChartElement.prototype );\n    Axis.prototype.constructor = Axis;\n\n    Axis.prototype.initFields = function initFields () {\n    };\n\n    // abstract labelsCount(): Number\n    // abstract createAxisLabel(index, options): AxisLabel\n\n    Axis.prototype.labelsRange = function labelsRange () {\n        return {\n            min: this.options.labels.skip,\n            max: this.labelsCount()\n        };\n    };\n\n    Axis.prototype.normalizeLabelRotation = function normalizeLabelRotation (labelOptions) {\n        var rotation = labelOptions.rotation;\n\n        if (isObject(rotation)) {\n            labelOptions.alignRotation = rotation.align;\n            labelOptions.rotation = rotation.angle;\n        }\n    };\n\n    Axis.prototype.createLabels = function createLabels () {\n        var this$1 = this;\n\n        var options = this.options;\n        var align = options.vertical ? RIGHT : CENTER;\n        var labelOptions = deepExtend({ }, options.labels, {\n            align: align,\n            zIndex: options.zIndex\n        });\n        var step = Math.max(1, labelOptions.step);\n\n        this.clearLabels();\n\n        if (labelOptions.visible) {\n            this.normalizeLabelRotation(labelOptions);\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateLabels = true;\n            }\n\n            var range = this.labelsRange();\n            for (var idx = range.min; idx < range.max; idx += step) {\n                var labelContext = { index: idx, count: range.max };\n                var label = this$1.createAxisLabel(idx, labelOptions, labelContext);\n                if (label) {\n                    this$1.append(label);\n                    this$1.labels.push(label);\n                }\n            }\n        }\n    };\n\n    Axis.prototype.clearLabels = function clearLabels () {\n        this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\n        this.labels = [];\n    };\n\n    Axis.prototype.clearTitle = function clearTitle () {\n        var this$1 = this;\n\n        if (this.title) {\n            this.children = grep(this.children, function (child) { return child !== this$1.title; });\n            this.title = undefined;\n        }\n    };\n\n    Axis.prototype.clear = function clear () {\n        this.clearLabels();\n        this.clearTitle();\n    };\n\n    Axis.prototype.lineBox = function lineBox () {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var axisX = mirror ? box.x1 : box.x2;\n        var axisY = mirror ? box.y2 : box.y1;\n        var lineWidth = options.line.width || 0;\n\n        return vertical ?\n            new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n            new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n    };\n\n    Axis.prototype.createTitle = function createTitle () {\n        var options = this.options;\n        var titleOptions = deepExtend({\n            rotation: options.vertical ? -90 : 0,\n            text: \"\",\n            zIndex: 1,\n            visualSize: true\n        }, options.title);\n\n        if (titleOptions.visible && titleOptions.text) {\n            var title = new TextBox(titleOptions.text, titleOptions);\n            this.append(title);\n            this.title = title;\n        }\n    };\n\n    Axis.prototype.createNotes = function createNotes () {\n        var this$1 = this;\n\n        var options = this.options;\n        var notes = options.notes;\n        var items = notes.data || [];\n\n        this.notes = [];\n\n        for (var i = 0; i < items.length; i++) {\n            var item = deepExtend({}, notes, items[i]);\n            item.value = this$1.parseNoteValue(item.value);\n\n            var note = new Note({\n                value: item.value,\n                text: item.label.text,\n                dataItem: item\n            }, item, this$1.chartService);\n\n            if (note.options.visible) {\n                if (defined(note.options.position)) {\n                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                } else {\n                    if (options.vertical) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                }\n                this$1.append(note);\n                this$1.notes.push(note);\n            }\n        }\n    };\n\n    Axis.prototype.parseNoteValue = function parseNoteValue (value) {\n        return value;\n    };\n\n    Axis.prototype.renderVisual = function renderVisual () {\n        ChartElement.prototype.renderVisual.call(this);\n\n        this.createPlotBands();\n    };\n\n    Axis.prototype.createVisual = function createVisual () {\n        ChartElement.prototype.createVisual.call(this);\n\n        this.createBackground();\n        this.createLine();\n    };\n\n    Axis.prototype.gridLinesVisual = function gridLinesVisual () {\n        var gridLines = this._gridLines;\n        if (!gridLines) {\n            gridLines = this._gridLines = new draw.Group({\n                zIndex: -2\n            });\n            this.appendVisual(this._gridLines);\n        }\n\n        return gridLines;\n    };\n\n    Axis.prototype.createTicks = function createTicks (lineGroup) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var mirror = options.labels.mirror;\n        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        var tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: options.vertical\n        };\n\n        function render(tickPositions, tickOptions, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, tickOptions.step);\n\n            if (tickOptions.visible) {\n                for (var i = tickOptions.skip; i < count; i += step) {\n                    if (defined(skipUnit) && (i % skipUnit === 0)) {\n                        continue;\n                    }\n\n                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                    tickLineOptions.position = tickPositions[i];\n\n                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), options.majorTicks);\n        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n    };\n\n    Axis.prototype.createLine = function createLine () {\n        var options = this.options;\n        var line = options.line;\n        var lineBox = this.lineBox();\n\n        if (line.width > 0 && line.visible) {\n            var path = new draw.Path({\n                stroke: {\n                    width: line.width,\n                    color: line.color,\n                    dashType: line.dashType\n                }\n\n                /* TODO\n                zIndex: line.zIndex,\n                */\n            });\n\n            path.moveTo(lineBox.x1, lineBox.y1)\n                .lineTo(lineBox.x2, lineBox.y2);\n\n            if (options._alignLines) {\n                alignPathToPixel(path);\n            }\n\n            var group = this._lineGroup = new draw.Group();\n            group.append(path);\n\n            this.visual.append(group);\n            this.createTicks(group);\n        }\n    };\n\n    Axis.prototype.getActualTickSize = function getActualTickSize () {\n        var options = this.options;\n        var tickSize = 0;\n\n        if (options.majorTicks.visible && options.minorTicks.visible) {\n            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n        } else if (options.majorTicks.visible) {\n            tickSize = options.majorTicks.size;\n        } else if (options.minorTicks.visible) {\n            tickSize = options.minorTicks.size;\n        }\n\n        return tickSize;\n    };\n\n    Axis.prototype.createBackground = function createBackground () {\n        var ref = this;\n        var options = ref.options;\n        var box = ref.box;\n        var background = options.background;\n\n        if (background) {\n            this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n                fill: {\n                    color: background\n                },\n                stroke: null\n            });\n\n            this.visual.append(this._backgroundPath);\n        }\n    };\n\n    Axis.prototype.createPlotBands = function createPlotBands () {\n        var this$1 = this;\n\n        var options = this.options;\n        var plotBands = options.plotBands || [];\n        var vertical = options.vertical;\n        var plotArea = this.plotArea;\n\n        if (plotBands.length === 0) {\n            return;\n        }\n\n        var group = this._plotbandGroup = new draw.Group({\n            zIndex: -1\n        });\n\n        var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1.options.vertical; })[0];\n\n        for (var idx = 0; idx < plotBands.length; idx++) {\n            var item = plotBands[idx];\n            var slotX = (void 0), slotY = (void 0);\n            var labelOptions = item.label;\n            var label = (void 0);\n\n            if (vertical) {\n                slotX = (altAxis || plotArea.axisX).lineBox();\n                slotY = this$1.getSlot(item.from, item.to, true);\n            } else {\n                slotX = this$1.getSlot(item.from, item.to, true);\n                slotY = (altAxis || plotArea.axisY).lineBox();\n            }\n\n            if (labelOptions) {\n                labelOptions.vAlign = labelOptions.position || LEFT;\n                label = this$1.createPlotBandLabel(\n                    labelOptions,\n                    item,\n                    new Box(\n                        slotX.x1,\n                        slotY.y1,\n                        slotX.x2,\n                        slotY.y2\n                    )\n\n                );\n            }\n\n            if (slotX.width() !== 0 && slotY.height() !== 0) {\n                var bandRect = new geom.Rect(\n                    [ slotX.x1, slotY.y1 ],\n                    [ slotX.width(), slotY.height() ]\n                );\n\n                var path = draw.Path.fromRect(bandRect, {\n                    fill: {\n                        color: item.color,\n                        opacity: item.opacity\n                    },\n                    stroke: null\n                });\n\n                group.append(path);\n                if (label) {\n                    group.append(label);\n                }\n            }\n        }\n\n        this.appendVisual(group);\n    };\n\n    Axis.prototype.createPlotBandLabel = function createPlotBandLabel (label, item, box) {\n\n        if (label.visible === false) {\n            return null;\n        }\n\n        var text = label.text;\n        var textbox;\n\n        if (defined(label) && label.visible) {\n            var labelTemplate = getTemplate(label);\n            if (labelTemplate) {\n                text = labelTemplate({ text: text, item: item });\n            } else if (label.format) {\n                text = this.chartService.format.auto(label.format, text);\n            }\n\n            if (!label.color) {\n                label.color = this.options.labels.color;\n            }\n        }\n\n        textbox = new TextBox(text, label);\n        textbox.reflow(box);\n        textbox.renderVisual();\n\n        return textbox.visual;\n    };\n\n    Axis.prototype.createGridLines = function createGridLines (altAxis) {\n        var options = this.options;\n        var minorGridLines = options.minorGridLines;\n        var majorGridLines = options.majorGridLines;\n        var minorUnit = options.minorUnit;\n        var vertical = options.vertical;\n        var axisLineVisible = altAxis.options.line.visible;\n        var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n        var lineBox = altAxis.lineBox();\n        var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n        var lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        var majorTicks = [];\n\n        var container = this.gridLinesVisual();\n\n        function render(tickPositions, gridLine, skipUnit) {\n            var count = tickPositions.length;\n            var step = Math.max(1, gridLine.step);\n\n            if (gridLine.visible) {\n                for (var i = gridLine.skip; i < count; i += step) {\n                    var pos = round(tickPositions[i]);\n                    if (!inArray(pos, majorTicks)) {\n                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                            lineOptions.position = pos;\n                            container.append(createAxisGridLine(lineOptions, gridLine));\n\n                            majorTicks.push(pos);\n                        }\n                    }\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), majorGridLines);\n        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n        return container.children;\n    };\n\n    Axis.prototype.reflow = function reflow (box) {\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var title = ref.title;\n        var vertical = options.vertical;\n        var count = labels.length;\n        var sizeFn = vertical ? WIDTH : HEIGHT;\n        var titleSize = title ? title.box[sizeFn]() : 0;\n        var space = this.getActualTickSize() + options.margin + titleSize;\n        var rootBox = (this.getRoot() || {}).box || box;\n        var boxSize = rootBox[sizeFn]();\n        var maxLabelSize = 0;\n\n        for (var i = 0; i < count; i++) {\n            var labelSize = labels[i].box[sizeFn]();\n            if (labelSize + space <= boxSize) {\n                maxLabelSize = Math.max(maxLabelSize, labelSize);\n            }\n        }\n\n        if (vertical) {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x1 + maxLabelSize + space, box.y2\n            );\n        } else {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x2, box.y1 + maxLabelSize + space\n            );\n        }\n\n        this.arrangeTitle();\n        this.arrangeLabels();\n        this.arrangeNotes();\n    };\n\n    Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions () {\n        return this.getMajorTickPositions();\n    };\n\n    Axis.prototype.labelTickIndex = function labelTickIndex (label) {\n        return label.index;\n    };\n\n    Axis.prototype.arrangeLabels = function arrangeLabels () {\n        var this$1 = this;\n\n        var ref = this;\n        var options = ref.options;\n        var labels = ref.labels;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var tickPositions = this.getLabelsTickPositions();\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1.labelTickIndex(label);\n            var labelSize = vertical ? label.box.height() : label.box.width();\n            var firstTickPosition = tickPositions[tickIx];\n            var nextTickPosition = tickPositions[tickIx + 1];\n            var positionStart = (void 0), positionEnd = (void 0);\n\n            if (vertical) {\n                if (labelsBetweenTicks) {\n                    var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                    positionStart = middle - (labelSize / 2);\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                }\n\n                positionEnd = positionStart;\n            } else {\n                if (labelsBetweenTicks) {\n                    positionStart = firstTickPosition;\n                    positionEnd = nextTickPosition;\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                    positionEnd = positionStart + labelSize;\n                }\n            }\n\n            this$1.positionLabel(label, mirror, positionStart, positionEnd);\n        }\n    };\n\n    Axis.prototype.positionLabel = function positionLabel (label, mirror, positionStart, positionEnd) {\n        if ( positionEnd === void 0 ) positionEnd = positionStart;\n\n        var options = this.options;\n        var vertical = options.vertical;\n        var lineBox = this.lineBox();\n        var labelOffset = this.getActualTickSize() + options.margin;\n        var labelBox;\n\n        if (vertical) {\n            var labelX = lineBox.x2;\n\n            if (mirror) {\n                labelX += labelOffset;\n                label.options.rotationOrigin = LEFT;\n            } else {\n                labelX -= labelOffset + label.box.width();\n                label.options.rotationOrigin = RIGHT;\n            }\n\n            labelBox = label.box.move(labelX, positionStart);\n        } else {\n            var labelY = lineBox.y1;\n\n            if (mirror) {\n                labelY -= labelOffset + label.box.height();\n                label.options.rotationOrigin = BOTTOM;\n            } else {\n                labelY += labelOffset;\n                label.options.rotationOrigin = TOP;\n            }\n\n            labelBox = new Box(\n                positionStart, labelY,\n                positionEnd, labelY + label.box.height()\n            );\n        }\n\n        label.reflow(labelBox);\n    };\n\n    Axis.prototype.autoRotateLabelAngle = function autoRotateLabelAngle (labelBox, slotWidth) {\n        if (labelBox.width() < slotWidth) {\n            return 0;\n        }\n\n        if (labelBox.height() > slotWidth) {\n            return -90;\n        }\n\n        return -45;\n    };\n\n    Axis.prototype.autoRotateLabels = function autoRotateLabels () {\n        var this$1 = this;\n\n        if (!this.options.autoRotateLabels || this.options.vertical) {\n            return false;\n        }\n\n        var tickPositions = this.getMajorTickPositions();\n        var labels = this.labels;\n        var limit = Math.min(labels.length, tickPositions.length - 1);\n        var angle = 0;\n\n        for (var idx = 0; idx < limit; idx++) {\n            var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n            var labelBox = labels[idx].box;\n            var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);\n\n            if (labelAngle !== 0) {\n                angle = labelAngle;\n            }\n\n            if (angle === -90) {\n                break;\n            }\n        }\n\n        if (angle !== 0) {\n            for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n                labels[idx$1].options.rotation = angle;\n                labels[idx$1].reflow(new Box());\n            }\n\n            return true;\n        }\n    };\n\n    Axis.prototype.arrangeTitle = function arrangeTitle () {\n        var ref = this;\n        var options = ref.options;\n        var title = ref.title;\n        var mirror = options.labels.mirror;\n        var vertical = options.vertical;\n\n        if (title) {\n            if (vertical) {\n                title.options.align = mirror ? RIGHT : LEFT;\n                title.options.vAlign = title.options.position;\n            } else {\n                title.options.align = title.options.position;\n                title.options.vAlign = mirror ? TOP : BOTTOM;\n            }\n\n            title.reflow(this.box);\n        }\n    };\n\n    Axis.prototype.arrangeNotes = function arrangeNotes () {\n        var this$1 = this;\n\n        for (var idx = 0; idx < this.notes.length; idx++) {\n            var item = this$1.notes[idx];\n            var value = item.options.value;\n            var slot = (void 0);\n\n            if (defined(value)) {\n                if (this$1.shouldRenderNote(value)) {\n                    item.show();\n                } else {\n                    item.hide();\n                }\n\n                slot = this$1.noteSlot(value);\n            } else {\n                item.hide();\n            }\n\n            item.reflow(slot || this$1.lineBox());\n        }\n    };\n\n    Axis.prototype.noteSlot = function noteSlot (value) {\n        return this.getSlot(value);\n    };\n\n    Axis.prototype.alignTo = function alignTo (secondAxis) {\n        var lineBox = secondAxis.lineBox();\n        var vertical = this.options.vertical;\n        var pos = vertical ? Y : X;\n\n        this.box.snapTo(lineBox, pos);\n        if (vertical) {\n            this.box.shrink(0, this.lineBox().height() - lineBox.height());\n        } else {\n            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n        }\n        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n    };\n\n    Axis.prototype.axisLabelText = function axisLabelText (value, options, context) {\n        var this$1 = this;\n\n        var text;\n        var tmpl = getTemplate(options);\n        var defaultText = function () {\n            if (!options.format) {\n                return value;\n            }\n\n            return this$1.chartService.format.localeAuto(\n                options.format, [ value ], options.culture\n            );\n        };\n\n        if (tmpl) {\n            var templateContext = Object.assign({}, context, {\n                get text() { return defaultText(); },\n                value: value,\n                format: options.format,\n                culture: options.culture\n            });\n\n            text = tmpl(templateContext);\n        } else {\n            text = defaultText();\n        }\n\n        return text;\n    };\n\n    Axis.prototype.slot = function slot (from , to, limit) {\n        var slot = this.getSlot(from, to, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    };\n\n    Axis.prototype.contentBox = function contentBox () {\n        var box = this.box.clone();\n        var labels = this.labels;\n        if (labels.length) {\n            var axis = this.options.vertical ? Y : X;\n            if (this.chartService.isPannable(axis)) {\n                var offset = this.maxLabelOffset();\n                box[axis + 1] -= offset.start;\n                box[axis + 2] += offset.end;\n            } else {\n                if (labels[0].options.visible) {\n                    box.wrap(labels[0].box);\n                }\n                var lastLabel = labels[labels.length - 1];\n                if (lastLabel.options.visible) {\n                    box.wrap(lastLabel.box);\n                }\n            }\n        }\n\n        return box;\n    };\n\n    Axis.prototype.maxLabelOffset = function maxLabelOffset () {\n        var this$1 = this;\n\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var labelsBetweenTicks = this.labelsBetweenTicks();\n        var tickPositions = this.getLabelsTickPositions();\n        var offsetField = vertical ? Y : X;\n        var labels = this.labels;\n        var startPosition = reverse ? 1 : 0;\n        var endPosition = reverse ? 0 : 1;\n        var maxStartOffset = 0;\n        var maxEndOffset = 0;\n\n        for (var idx = 0; idx < labels.length; idx++) {\n            var label = labels[idx];\n            var tickIx = this$1.labelTickIndex(label);\n            var startTick = (void 0), endTick = (void 0);\n\n            if (labelsBetweenTicks) {\n                startTick = tickPositions[tickIx + startPosition];\n                endTick = tickPositions[tickIx + endPosition];\n            } else {\n                startTick = endTick = tickPositions[tickIx];\n            }\n\n            maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n            maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n        }\n\n        return {\n            start: maxStartOffset,\n            end: maxEndOffset\n        };\n    };\n\n    Axis.prototype.limitRange = function limitRange (from, to, min, max, offset) {\n        var options = this.options;\n\n        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n            return null;\n        }\n\n        if ((to < min && offset > 0) || (max < from && offset < 0)) {\n            return {\n                min: from,\n                max: to\n            };\n        }\n\n        var rangeSize = to - from;\n        var minValue = from;\n        var maxValue = to;\n\n        if (from < min && offset < 0) {\n            minValue = limitValue(from, min, max);\n            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n        } else if (to > max && offset > 0) {\n            maxValue = limitValue(to, min, max);\n            minValue = limitValue(to - rangeSize, min, max - rangeSize);\n        }\n\n        return {\n            min: minValue,\n            max: maxValue\n        };\n    };\n\n    Axis.prototype.valueRange = function valueRange () {\n        return {\n            min: this.seriesMin,\n            max: this.seriesMax\n        };\n    };\n\n    Axis.prototype.lineDir = function lineDir () {\n        /*\n         * Axis line direction:\n         *   * Vertical: up.\n         *   * Horizontal: right.\n         */\n\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n    };\n\n    Axis.prototype.lineInfo = function lineInfo () {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var lineBox = this.lineBox();\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var axis = vertical ? Y : X;\n        var axisDir = this.lineDir();\n        var startEdge = axisDir === 1 ? 1 : 2;\n        var axisOrigin = axis + startEdge.toString();\n        var lineStart = lineBox[axisOrigin];\n\n        return {\n            axis: axis,\n            axisOrigin: axisOrigin,\n            axisDir: axisDir,\n            lineBox: lineBox,\n            lineSize: lineSize,\n            lineStart: lineStart\n        };\n    };\n\n    Axis.prototype.pointOffset = function pointOffset (point) {\n        var ref = this.lineInfo();\n        var axis = ref.axis;\n        var axisDir = ref.axisDir;\n        var axisOrigin = ref.axisOrigin;\n        var lineBox = ref.lineBox;\n        var lineSize = ref.lineSize;\n        var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n        var offset = relative / lineSize;\n\n        return offset;\n    };\n\n    // Computes the axis range change (delta) for a given scale factor.\n    // The delta is subtracted from the axis range:\n    //   * delta > 0 reduces the axis range (zoom-in)\n    //   * delta < 0 expands the axis range (zoom-out)\n    Axis.prototype.scaleToDelta = function scaleToDelta (rawScale, range) {\n        // Scale >= 1 would result in axis range of 0.\n        // Scale <= -1 would reverse the scale direction.\n        var MAX_SCALE = 0.999;\n        var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n\n        var delta;\n        if (scale > 0) {\n            delta = range * Math.min(1, scale);\n        } else {\n            delta = range - (range / (1 + scale));\n        }\n\n        return delta;\n    };\n\n    Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks () {\n        return !this.options.justified;\n    };\n\n    //add legacy fields to the options that are no longer generated by default\n    Axis.prototype.prepareUserOptions = function prepareUserOptions () {\n    };\n\n    return Axis;\n}(ChartElement));\n\nsetDefaultOptions(Axis, {\n    labels: {\n        visible: true,\n        rotation: 0,\n        mirror: false,\n        step: 1,\n        skip: 0\n    },\n    line: {\n        width: 1,\n        color: BLACK,\n        visible: true\n    },\n    title: {\n        visible: true,\n        position: CENTER\n    },\n    majorTicks: {\n        align: OUTSIDE,\n        size: 4,\n        skip: 0,\n        step: 1\n    },\n    minorTicks: {\n        align: OUTSIDE,\n        size: 3,\n        skip: 0,\n        step: 1\n    },\n    axisCrossingValue: 0,\n    majorTickType: OUTSIDE,\n    minorTickType: NONE,\n    majorGridLines: {\n        skip: 0,\n        step: 1\n    },\n    minorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK,\n        skip: 0,\n        step: 1\n    },\n    // TODO: Move to line or labels options\n    margin: 5,\n    visible: true,\n    reverse: false,\n    justified: true,\n    notes: {\n        label: {\n            text: \"\"\n        }\n    },\n\n    _alignLines: true,\n    _deferLabels: false\n});\n\nexport default Axis;\n"]},"metadata":{},"sourceType":"module"}