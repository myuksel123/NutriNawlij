{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport { BLACK, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { defined, isNumber, last, limitValue, round, setDefaultOptions, valueOrDefault, HashMap } from '../common';\nimport { dateEquals } from '../date-utils';\nvar MIN_CATEGORY_POINTS_RANGE = 0.01;\nvar MIN_CATEGORY_RANGE = 0.1;\n\nfunction indexOf(value, arr) {\n  if (value instanceof Date) {\n    var length = arr.length;\n\n    for (var idx = 0; idx < length; idx++) {\n      if (dateEquals(arr[idx], value)) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n\n  return arr.indexOf(value);\n}\n\nvar CategoryAxis = function (Axis) {\n  function CategoryAxis() {\n    Axis.apply(this, arguments);\n  }\n\n  if (Axis) CategoryAxis.__proto__ = Axis;\n  CategoryAxis.prototype = Object.create(Axis && Axis.prototype);\n  CategoryAxis.prototype.constructor = CategoryAxis;\n\n  CategoryAxis.prototype.initFields = function initFields() {\n    this._ticks = {};\n  };\n\n  CategoryAxis.prototype.categoriesHash = function categoriesHash() {\n    return \"\";\n  };\n\n  CategoryAxis.prototype.clone = function clone() {\n    var copy = new CategoryAxis(Object.assign({}, this.options, {\n      categories: this.options.srcCategories\n    }), this.chartService);\n    copy.createLabels();\n    return copy;\n  };\n\n  CategoryAxis.prototype.initUserOptions = function initUserOptions(options) {\n    var categories = options.categories || [];\n    var definedMin = defined(options.min);\n    var definedMax = defined(options.max);\n    options.srcCategories = options.categories = categories;\n\n    if ((definedMin || definedMax) && categories.length) {\n      var min = definedMin ? Math.floor(options.min) : 0;\n      var max;\n\n      if (definedMax) {\n        max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n      } else {\n        max = categories.length;\n      }\n\n      options.categories = options.categories.slice(min, max);\n    }\n\n    return options;\n  };\n\n  CategoryAxis.prototype.rangeIndices = function rangeIndices() {\n    var options = this.options;\n    var length = options.categories.length || 1;\n    var min = isNumber(options.min) ? options.min % 1 : 0;\n    var max;\n\n    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n      max = length - (1 - options.max % 1);\n    } else {\n      max = length - (options.justified ? 1 : 0);\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  CategoryAxis.prototype.totalRangeIndices = function totalRangeIndices(limit) {\n    var options = this.options;\n    var min = isNumber(options.min) ? options.min : 0;\n    var max;\n\n    if (isNumber(options.max)) {\n      max = options.max;\n    } else if (isNumber(options.min)) {\n      max = min + options.categories.length;\n    } else {\n      max = this.totalRange().max || 1;\n    }\n\n    if (limit) {\n      var totalRange = this.totalRange();\n      min = limitValue(min, 0, totalRange.max);\n      max = limitValue(max, 0, totalRange.max);\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  CategoryAxis.prototype.range = function range() {\n    var options = this.options;\n    var min = isNumber(options.min) ? options.min : 0;\n    var max = isNumber(options.max) ? options.max : this.totalRange().max;\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  CategoryAxis.prototype.roundedRange = function roundedRange() {\n    return this.range();\n  };\n\n  CategoryAxis.prototype.totalRange = function totalRange() {\n    var options = this.options;\n    return {\n      min: 0,\n      max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0)\n    };\n  };\n\n  CategoryAxis.prototype.scaleOptions = function scaleOptions() {\n    var ref = this.rangeIndices();\n    var min = ref.min;\n    var max = ref.max;\n    var lineBox = this.lineBox();\n    var size = this.options.vertical ? lineBox.height() : lineBox.width();\n    var scale = size / (max - min || 1);\n    return {\n      scale: scale * (this.options.reverse ? -1 : 1),\n      box: lineBox,\n      min: min,\n      max: max\n    };\n  };\n\n  CategoryAxis.prototype.arrangeLabels = function arrangeLabels() {\n    Axis.prototype.arrangeLabels.call(this);\n    this.hideOutOfRangeLabels();\n  };\n\n  CategoryAxis.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {\n    var ref = this;\n    var box = ref.box;\n    var labels = ref.labels;\n\n    if (labels.length > 0) {\n      var valueAxis = this.options.vertical ? Y : X;\n      var start = box[valueAxis + 1];\n      var end = box[valueAxis + 2];\n      var firstLabel = labels[0];\n      var lastLabel = last(labels);\n\n      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n        firstLabel.options.visible = false;\n      }\n\n      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n        lastLabel.options.visible = false;\n      }\n    }\n  };\n\n  CategoryAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    return this.getTicks().majorTicks;\n  };\n\n  CategoryAxis.prototype.getMinorTickPositions = function getMinorTickPositions() {\n    return this.getTicks().minorTicks;\n  };\n\n  CategoryAxis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getTicks().labelTicks;\n  };\n\n  CategoryAxis.prototype.tickIndices = function tickIndices(stepSize) {\n    var ref = this.rangeIndices();\n    var min = ref.min;\n    var max = ref.max;\n    var limit = Math.ceil(max);\n    var current = Math.floor(min);\n    var indices = [];\n\n    while (current <= limit) {\n      indices.push(current);\n      current += stepSize;\n    }\n\n    return indices;\n  };\n\n  CategoryAxis.prototype.getTickPositions = function getTickPositions(stepSize) {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var min = ref$1.min;\n    var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n    var indices = this.tickIndices(stepSize);\n    var positions = [];\n\n    for (var idx = 0; idx < indices.length; idx++) {\n      positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n    }\n\n    return positions;\n  };\n\n  CategoryAxis.prototype.getTicks = function getTicks() {\n    var options = this.options;\n    var cache = this._ticks;\n    var range = this.rangeIndices();\n    var lineBox = this.lineBox();\n    var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n    if (cache._hash !== hash) {\n      var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n      cache._hash = hash;\n      cache.labelTicks = this.getTickPositions(1);\n      cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n      cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n    }\n\n    return cache;\n  };\n\n  CategoryAxis.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {\n    if (!positions.length) {\n      return positions;\n    }\n\n    var axis = this.options.vertical ? Y : X;\n\n    var inRange = function (position) {\n      return lineBox[axis + 1] <= position && position <= lineBox[axis + 2];\n    };\n\n    var end = positions.length - 1;\n    var startIndex = 0;\n\n    while (!inRange(positions[startIndex]) && startIndex <= end) {\n      startIndex++;\n    }\n\n    var endIndex = end;\n\n    while (!inRange(positions[endIndex]) && endIndex >= 0) {\n      endIndex--;\n    }\n\n    return positions.slice(startIndex, endIndex + 1);\n  };\n\n  CategoryAxis.prototype.lineInfo = function lineInfo() {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var lineBox = this.lineBox();\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var axis = vertical ? Y : X;\n    var axisDir = reverse ? -1 : 1;\n    var startEdge = axisDir === 1 ? 1 : 2;\n    var axisOrigin = axis + startEdge.toString();\n    var lineStart = lineBox[axisOrigin];\n    return {\n      axis: axis,\n      axisOrigin: axisOrigin,\n      axisDir: axisDir,\n      lineBox: lineBox,\n      lineSize: lineSize,\n      lineStart: lineStart\n    };\n  };\n\n  CategoryAxis.prototype.lineDir = function lineDir() {\n    /*\n     *  Category axis line direction:\n     *    * Vertical: down.\n     *    * Horizontal: right.\n     */\n    var ref = this.options;\n    var reverse = ref.reverse;\n    return reverse ? -1 : 1;\n  }; // TODO: Rename to slotBox, valueSlot, slotByIndex?\n\n\n  CategoryAxis.prototype.getSlot = function getSlot(from, to, limit) {\n    var options = this.options;\n    var reverse = options.reverse;\n    var justified = options.justified;\n    var ref = this.scaleOptions();\n    var scale = ref.scale;\n    var box = ref.box;\n    var min = ref.min;\n    var ref$1 = this.lineInfo();\n    var valueAxis = ref$1.axis;\n    var lineStart = ref$1.lineStart;\n    var slotBox = box.clone();\n    var singleSlot = !defined(to);\n    var start = valueOrDefault(from, 0);\n    var end = valueOrDefault(to, start);\n    end = Math.max(end - 1, start); // Fixes transient bug caused by iOS 6.0 JIT\n    // (one can never be too sure)\n\n    end = Math.max(start, end);\n    var p1 = lineStart + (start - min) * scale;\n    var p2 = lineStart + (end + 1 - min) * scale;\n\n    if (singleSlot && justified) {\n      p2 = p1;\n    }\n\n    if (limit) {\n      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n      p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n    }\n\n    slotBox[valueAxis + 1] = reverse ? p2 : p1;\n    slotBox[valueAxis + 2] = reverse ? p1 : p2;\n    return slotBox;\n  };\n\n  CategoryAxis.prototype.limitSlot = function limitSlot(slot) {\n    var vertical = this.options.vertical;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var limittedSlot = slot.clone();\n    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    return limittedSlot;\n  };\n\n  CategoryAxis.prototype.slot = function slot(from, to, limit) {\n    var min = Math.floor(this.options.min || 0);\n    var start = from;\n    var end = to;\n\n    if (typeof start === \"string\") {\n      start = this.categoryIndex(start);\n    } else if (isNumber(start)) {\n      start -= min;\n    }\n\n    if (typeof end === \"string\") {\n      end = this.categoryIndex(end);\n    } else if (isNumber(end)) {\n      end -= min;\n    }\n\n    return Axis.prototype.slot.call(this, start, end, limit);\n  };\n\n  CategoryAxis.prototype.pointCategoryIndex = function pointCategoryIndex(point) {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var justified = ref.justified;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var min = ref$1.min;\n    var max = ref$1.max;\n    var startValue = reverse ? max : min;\n    var lineStart = box[valueAxis + 1];\n    var lineEnd = box[valueAxis + 2];\n    var pos = point[valueAxis];\n\n    if (pos < lineStart || pos > lineEnd) {\n      return null;\n    }\n\n    var value = startValue + (pos - lineStart) / scale;\n    var diff = value % 1;\n\n    if (justified) {\n      value = Math.round(value);\n    } else if (diff === 0 && value > 0) {\n      value--;\n    }\n\n    return Math.floor(value);\n  };\n\n  CategoryAxis.prototype.getCategory = function getCategory(point) {\n    var index = this.pointCategoryIndex(point);\n\n    if (index === null) {\n      return null;\n    }\n\n    return this.options.categories[index];\n  };\n\n  CategoryAxis.prototype.categoryIndex = function categoryIndex(value) {\n    return this.totalIndex(value) - Math.floor(this.options.min || 0);\n  };\n\n  CategoryAxis.prototype.categoryAt = function categoryAt(index, total) {\n    var options = this.options;\n    return (total ? options.srcCategories : options.categories)[index];\n  };\n\n  CategoryAxis.prototype.categoriesCount = function categoriesCount() {\n    return (this.options.categories || []).length;\n  };\n\n  CategoryAxis.prototype.translateRange = function translateRange(delta) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var size = options.vertical ? lineBox.height() : lineBox.width();\n    var range = options.categories.length;\n    var scale = size / range;\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    return {\n      min: offset,\n      max: range + offset\n    };\n  };\n\n  CategoryAxis.prototype.scaleRange = function scaleRange(scale, cursor) {\n    var position = Math.abs(this.pointOffset(cursor));\n    var rangeIndices = this.totalRangeIndices();\n    var range = rangeIndices.max - rangeIndices.min;\n    var delta = this.scaleToDelta(scale, range);\n    var minDelta = position * delta;\n    var maxDelta = (1 - position) * delta;\n    var min = rangeIndices.min + minDelta;\n    var max = rangeIndices.max - maxDelta;\n\n    if (max - min < MIN_CATEGORY_RANGE) {\n      max = min + MIN_CATEGORY_RANGE;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  CategoryAxis.prototype.zoomRange = function zoomRange(scale, cursor) {\n    var ref = this.totalRange();\n    var totalMin = ref.min;\n    var totalMax = ref.max;\n    var range = this.scaleRange(scale, cursor);\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  };\n\n  CategoryAxis.prototype.labelsCount = function labelsCount() {\n    var labelsRange = this.labelsRange();\n    return labelsRange.max - labelsRange.min;\n  };\n\n  CategoryAxis.prototype.labelsRange = function labelsRange() {\n    var options = this.options;\n    var justified = options.justified;\n    var labelOptions = options.labels;\n    var ref = this.totalRangeIndices(true);\n    var min = ref.min;\n    var max = ref.max;\n    var start = Math.floor(min);\n\n    if (!justified) {\n      min = Math.floor(min);\n      max = Math.ceil(max);\n    } else {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n    }\n\n    var skip;\n\n    if (min > labelOptions.skip) {\n      skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n    } else {\n      skip = labelOptions.skip;\n    }\n\n    return {\n      min: skip - start,\n      max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n    };\n  };\n\n  CategoryAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {\n    var options = this.options;\n    var dataItem = options.dataItems ? options.dataItems[index] : null;\n    var category = valueOrDefault(options.categories[index], \"\");\n    labelContext.dataItem = dataItem;\n    var text = this.axisLabelText(category, labelOptions, labelContext);\n    return new AxisLabel(category, text, index, dataItem, labelOptions);\n  };\n\n  CategoryAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.totalRangeIndices();\n    return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n  };\n\n  CategoryAxis.prototype.noteSlot = function noteSlot(value) {\n    var options = this.options;\n    var index = value - Math.floor(options.min || 0);\n    return this.getSlot(index);\n  };\n\n  CategoryAxis.prototype.arrangeNotes = function arrangeNotes() {\n    Axis.prototype.arrangeNotes.call(this);\n    this.hideOutOfRangeNotes();\n  };\n\n  CategoryAxis.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {\n    var ref = this;\n    var notes = ref.notes;\n    var box = ref.box;\n\n    if (notes && notes.length) {\n      var valueAxis = this.options.vertical ? Y : X;\n      var start = box[valueAxis + 1];\n      var end = box[valueAxis + 2];\n\n      for (var idx = 0; idx < notes.length; idx++) {\n        var note = notes[idx];\n\n        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n          note.hide();\n        }\n      }\n    }\n  };\n\n  CategoryAxis.prototype.pan = function pan(delta) {\n    var range = this.totalRangeIndices(true);\n    var ref = this.scaleOptions();\n    var scale = ref.scale;\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    var totalRange = this.totalRange();\n    var min = range.min + offset;\n    var max = range.max + offset;\n    return this.limitRange(min, max, 0, totalRange.max, offset);\n  };\n\n  CategoryAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var range = this.totalRangeIndices(true);\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n    var diffStart = start[valueAxis] - lineStart;\n    var diffEnd = end[valueAxis] - lineStart;\n    var min = range.min + diffStart / scale;\n    var max = range.min + diffEnd / scale;\n    var rangeMin = Math.min(min, max);\n    var rangeMax = Math.max(min, max);\n\n    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n      return {\n        min: rangeMin,\n        max: rangeMax\n      };\n    }\n  };\n\n  CategoryAxis.prototype.valueRange = function valueRange() {\n    return this.range();\n  };\n\n  CategoryAxis.prototype.totalIndex = function totalIndex(value) {\n    var options = this.options;\n    var index = this._categoriesMap ? this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n    return index;\n  };\n\n  CategoryAxis.prototype.currentRangeIndices = function currentRangeIndices() {\n    var options = this.options;\n    var min = 0;\n\n    if (isNumber(options.min)) {\n      min = Math.floor(options.min);\n    }\n\n    var max;\n\n    if (isNumber(options.max)) {\n      max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n    } else {\n      max = this.totalCount() - 1;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  CategoryAxis.prototype.mapCategories = function mapCategories() {\n    if (!this._categoriesMap) {\n      var map = this._categoriesMap = new HashMap();\n      var srcCategories = this.options.srcCategories;\n\n      for (var idx = 0; idx < srcCategories.length; idx++) {\n        map.set(srcCategories[idx], idx);\n      }\n    }\n  };\n\n  CategoryAxis.prototype.totalCount = function totalCount() {\n    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n  };\n\n  return CategoryAxis;\n}(Axis);\n\nsetDefaultOptions(CategoryAxis, {\n  type: \"category\",\n  vertical: false,\n  majorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK\n  },\n  labels: {\n    zIndex: 1\n  },\n  justified: false,\n  _deferLabels: true\n});\nexport default CategoryAxis;","map":{"version":3,"sources":["/home/meryem/repos/Movie_Trend_Visualizer/client/node_modules/@progress/kendo-charts/dist/es/core/category-axis.js"],"names":["Axis","AxisLabel","BLACK","COORD_PRECISION","DEFAULT_PRECISION","X","Y","defined","isNumber","last","limitValue","round","setDefaultOptions","valueOrDefault","HashMap","dateEquals","MIN_CATEGORY_POINTS_RANGE","MIN_CATEGORY_RANGE","indexOf","value","arr","Date","length","idx","CategoryAxis","apply","arguments","__proto__","prototype","Object","create","constructor","initFields","_ticks","categoriesHash","clone","copy","assign","options","categories","srcCategories","chartService","createLabels","initUserOptions","definedMin","min","definedMax","max","Math","floor","justified","ceil","slice","rangeIndices","totalRange","totalRangeIndices","limit","range","roundedRange","_seriesMax","scaleOptions","ref","lineBox","size","vertical","height","width","scale","reverse","box","arrangeLabels","call","hideOutOfRangeLabels","labels","valueAxis","start","end","firstLabel","lastLabel","visible","getMajorTickPositions","getTicks","majorTicks","getMinorTickPositions","minorTicks","getLabelsTickPositions","labelTicks","tickIndices","stepSize","current","indices","push","getTickPositions","ref$1","pos","positions","cache","hash","getHash","_hash","hasMinor","minorGridLines","filterOutOfRangePositions","axis","inRange","position","startIndex","endIndex","lineInfo","lineSize","axisDir","startEdge","axisOrigin","toString","lineStart","lineDir","getSlot","from","to","slotBox","singleSlot","p1","p2","limitSlot","slot","limittedSlot","categoryIndex","pointCategoryIndex","point","startValue","lineEnd","diff","getCategory","index","totalIndex","categoryAt","total","categoriesCount","translateRange","delta","offset","scaleRange","cursor","abs","pointOffset","scaleToDelta","minDelta","maxDelta","zoomRange","totalMin","totalMax","labelsCount","labelsRange","labelOptions","skip","step","createAxisLabel","labelContext","dataItem","dataItems","category","text","axisLabelText","shouldRenderNote","noteSlot","arrangeNotes","hideOutOfRangeNotes","notes","note","hide","pan","limitRange","pointsRange","diffStart","diffEnd","rangeMin","rangeMax","valueRange","_categoriesMap","get","currentRangeIndices","totalCount","mapCategories","map","set","type","majorGridLines","color","zIndex","_deferLabels"],"mappings":"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","sourcesContent":["import Axis from './axis';\nimport AxisLabel from './axis-label';\n\nimport { BLACK, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { defined, isNumber, last, limitValue, round, setDefaultOptions, valueOrDefault, HashMap } from '../common';\nimport { dateEquals } from '../date-utils';\n\nvar MIN_CATEGORY_POINTS_RANGE = 0.01;\nvar MIN_CATEGORY_RANGE = 0.1;\n\nfunction indexOf(value, arr) {\n    if (value instanceof Date) {\n        var length = arr.length;\n        for (var idx = 0; idx < length; idx++) {\n            if (dateEquals(arr[idx], value)) {\n                return idx;\n            }\n        }\n\n        return -1;\n    }\n\n    return arr.indexOf(value);\n}\n\nvar CategoryAxis = (function (Axis) {\n    function CategoryAxis () {\n        Axis.apply(this, arguments);\n    }\n\n    if ( Axis ) CategoryAxis.__proto__ = Axis;\n    CategoryAxis.prototype = Object.create( Axis && Axis.prototype );\n    CategoryAxis.prototype.constructor = CategoryAxis;\n\n    CategoryAxis.prototype.initFields = function initFields () {\n        this._ticks = {};\n    };\n\n    CategoryAxis.prototype.categoriesHash = function categoriesHash () {\n        return \"\";\n    };\n\n    CategoryAxis.prototype.clone = function clone () {\n        var copy = new CategoryAxis(Object.assign({}, this.options, {\n            categories: this.options.srcCategories\n        }), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    };\n\n    CategoryAxis.prototype.initUserOptions = function initUserOptions (options) {\n        var categories = options.categories || [];\n        var definedMin = defined(options.min);\n        var definedMax = defined(options.max);\n        options.srcCategories = options.categories = categories;\n\n        if ((definedMin || definedMax) && categories.length) {\n            var min = definedMin ? Math.floor(options.min) : 0;\n            var max;\n\n            if (definedMax) {\n                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n            } else {\n                max = categories.length;\n            }\n\n            options.categories = options.categories.slice(min, max);\n        }\n\n        return options;\n    };\n\n    CategoryAxis.prototype.rangeIndices = function rangeIndices () {\n        var options = this.options;\n        var length = options.categories.length || 1;\n        var min = isNumber(options.min) ? options.min % 1 : 0;\n        var max;\n\n        if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n            max = length - (1 - options.max % 1);\n        } else {\n            max = length - (options.justified ? 1 : 0);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.totalRangeIndices = function totalRangeIndices (limit) {\n        var options = this.options;\n        var min = isNumber(options.min) ? options.min : 0;\n        var max;\n\n        if (isNumber(options.max)) {\n            max = options.max;\n        } else if (isNumber(options.min)) {\n            max = min + options.categories.length;\n        } else {\n            max = this.totalRange().max || 1;\n        }\n\n        if (limit) {\n            var totalRange = this.totalRange();\n            min = limitValue(min, 0, totalRange.max);\n            max = limitValue(max, 0, totalRange.max);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.range = function range () {\n        var options = this.options;\n        var min = isNumber(options.min) ? options.min : 0;\n        var max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.roundedRange = function roundedRange () {\n        return this.range();\n    };\n\n    CategoryAxis.prototype.totalRange = function totalRange () {\n        var options = this.options;\n        return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n    };\n\n    CategoryAxis.prototype.scaleOptions = function scaleOptions () {\n        var ref = this.rangeIndices();\n        var min = ref.min;\n        var max = ref.max;\n        var lineBox = this.lineBox();\n        var size = this.options.vertical ? lineBox.height() : lineBox.width();\n        var scale = size / ((max - min) || 1);\n\n        return {\n            scale: scale * (this.options.reverse ? -1 : 1),\n            box: lineBox,\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.arrangeLabels = function arrangeLabels () {\n        Axis.prototype.arrangeLabels.call(this);\n        this.hideOutOfRangeLabels();\n    };\n\n    CategoryAxis.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels () {\n        var ref = this;\n        var box = ref.box;\n        var labels = ref.labels;\n\n        if (labels.length > 0) {\n            var valueAxis = this.options.vertical ? Y : X;\n            var start = box[valueAxis + 1];\n            var end = box[valueAxis + 2];\n            var firstLabel = labels[0];\n            var lastLabel = last(labels);\n\n            if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                firstLabel.options.visible = false;\n            }\n            if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                lastLabel.options.visible = false;\n            }\n        }\n    };\n\n    CategoryAxis.prototype.getMajorTickPositions = function getMajorTickPositions () {\n        return this.getTicks().majorTicks;\n    };\n\n    CategoryAxis.prototype.getMinorTickPositions = function getMinorTickPositions () {\n        return this.getTicks().minorTicks;\n    };\n\n    CategoryAxis.prototype.getLabelsTickPositions = function getLabelsTickPositions () {\n        return this.getTicks().labelTicks;\n    };\n\n    CategoryAxis.prototype.tickIndices = function tickIndices (stepSize) {\n        var ref = this.rangeIndices();\n        var min = ref.min;\n        var max = ref.max;\n        var limit = Math.ceil(max);\n        var current = Math.floor(min);\n        var indices = [];\n\n        while (current <= limit) {\n            indices.push(current);\n            current += stepSize;\n        }\n\n        return indices;\n    };\n\n    CategoryAxis.prototype.getTickPositions = function getTickPositions (stepSize) {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var min = ref$1.min;\n        var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n        var indices = this.tickIndices(stepSize);\n        var positions = [];\n\n        for (var idx = 0; idx < indices.length; idx++) {\n            positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n        }\n\n        return positions;\n    };\n\n    CategoryAxis.prototype.getTicks = function getTicks () {\n        var options = this.options;\n        var cache = this._ticks;\n        var range = this.rangeIndices();\n        var lineBox = this.lineBox();\n        var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n        if (cache._hash !== hash) {\n            var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n            cache._hash = hash;\n            cache.labelTicks = this.getTickPositions(1);\n            cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n            cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n        }\n\n        return cache;\n    };\n\n    CategoryAxis.prototype.filterOutOfRangePositions = function filterOutOfRangePositions (positions, lineBox) {\n        if (!positions.length) {\n            return positions;\n        }\n\n        var axis = this.options.vertical ? Y : X;\n        var inRange = function (position) { return lineBox[axis + 1] <= position && position <= lineBox[axis + 2]; };\n\n        var end = positions.length - 1;\n        var startIndex = 0;\n        while (!inRange(positions[startIndex]) && startIndex <= end) {\n            startIndex++;\n        }\n\n        var endIndex = end;\n\n        while (!inRange(positions[endIndex]) && endIndex >= 0) {\n            endIndex--;\n        }\n\n        return positions.slice(startIndex, endIndex + 1);\n    };\n\n    CategoryAxis.prototype.lineInfo = function lineInfo () {\n        var ref = this.options;\n        var vertical = ref.vertical;\n        var reverse = ref.reverse;\n        var lineBox = this.lineBox();\n        var lineSize = vertical ? lineBox.height() : lineBox.width();\n        var axis = vertical ? Y : X;\n        var axisDir = reverse ? -1 : 1;\n        var startEdge = axisDir === 1 ? 1 : 2;\n        var axisOrigin = axis + startEdge.toString();\n        var lineStart = lineBox[axisOrigin];\n\n        return {\n            axis: axis,\n            axisOrigin: axisOrigin,\n            axisDir: axisDir,\n            lineBox: lineBox,\n            lineSize: lineSize,\n            lineStart: lineStart\n        };\n    };\n\n    CategoryAxis.prototype.lineDir = function lineDir () {\n        /*\n         *  Category axis line direction:\n         *    * Vertical: down.\n         *    * Horizontal: right.\n         */\n\n        var ref = this.options;\n        var reverse = ref.reverse;\n        return reverse ? -1 : 1;\n    };\n\n    // TODO: Rename to slotBox, valueSlot, slotByIndex?\n    CategoryAxis.prototype.getSlot = function getSlot (from, to, limit) {\n        var options = this.options;\n        var reverse = options.reverse;\n        var justified = options.justified;\n        var ref = this.scaleOptions();\n        var scale = ref.scale;\n        var box = ref.box;\n        var min = ref.min;\n        var ref$1 = this.lineInfo();\n        var valueAxis = ref$1.axis;\n        var lineStart = ref$1.lineStart;\n\n        var slotBox = box.clone();\n        var singleSlot = !defined(to);\n\n        var start = valueOrDefault(from, 0);\n        var end = valueOrDefault(to, start);\n        end = Math.max(end - 1, start);\n\n        // Fixes transient bug caused by iOS 6.0 JIT\n        // (one can never be too sure)\n        end = Math.max(start, end);\n\n        var p1 = lineStart + (start - min) * scale;\n        var p2 = lineStart + (end + 1 - min) * scale;\n\n        if (singleSlot && justified) {\n            p2 = p1;\n        }\n\n        if (limit) {\n            p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n            p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n        }\n\n        slotBox[valueAxis + 1] = reverse ? p2 : p1;\n        slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n        return slotBox;\n    };\n\n    CategoryAxis.prototype.limitSlot = function limitSlot (slot) {\n        var vertical = this.options.vertical;\n        var valueAxis = vertical ? Y : X;\n        var lineBox = this.lineBox();\n        var limittedSlot = slot.clone();\n\n        limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n        limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n        return limittedSlot;\n    };\n\n    CategoryAxis.prototype.slot = function slot (from, to, limit) {\n        var min = Math.floor(this.options.min || 0);\n        var start = from;\n        var end = to;\n\n        if (typeof start === \"string\") {\n            start = this.categoryIndex(start);\n        } else if (isNumber(start)) {\n            start -= min;\n        }\n\n        if (typeof end === \"string\") {\n            end = this.categoryIndex(end);\n        } else if (isNumber(end)) {\n            end -= min;\n        }\n\n        return Axis.prototype.slot.call(this, start, end, limit);\n    };\n\n    CategoryAxis.prototype.pointCategoryIndex = function pointCategoryIndex (point) {\n        var ref = this.options;\n        var reverse = ref.reverse;\n        var justified = ref.justified;\n        var vertical = ref.vertical;\n        var valueAxis = vertical ? Y : X;\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var min = ref$1.min;\n        var max = ref$1.max;\n        var startValue = reverse ? max : min;\n        var lineStart = box[valueAxis + 1];\n        var lineEnd = box[valueAxis + 2];\n        var pos = point[valueAxis];\n\n        if (pos < lineStart || pos > lineEnd) {\n            return null;\n        }\n\n        var value = startValue + (pos - lineStart) / scale;\n        var diff = value % 1;\n\n        if (justified) {\n            value = Math.round(value);\n        } else if (diff === 0 && value > 0) {\n            value--;\n        }\n\n        return Math.floor(value);\n    };\n\n    CategoryAxis.prototype.getCategory = function getCategory (point) {\n        var index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.options.categories[index];\n    };\n\n    CategoryAxis.prototype.categoryIndex = function categoryIndex (value) {\n        return this.totalIndex(value) - Math.floor(this.options.min || 0);\n    };\n\n    CategoryAxis.prototype.categoryAt = function categoryAt (index, total) {\n        var options = this.options;\n\n        return (total ? options.srcCategories : options.categories)[index];\n    };\n\n    CategoryAxis.prototype.categoriesCount = function categoriesCount () {\n        return (this.options.categories || []).length;\n    };\n\n    CategoryAxis.prototype.translateRange = function translateRange (delta) {\n        var options = this.options;\n        var lineBox = this.lineBox();\n        var size = options.vertical ? lineBox.height() : lineBox.width();\n        var range = options.categories.length;\n        var scale = size / range;\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n\n        return {\n            min: offset,\n            max: range + offset\n        };\n    };\n\n    CategoryAxis.prototype.scaleRange = function scaleRange (scale, cursor) {\n        var position = Math.abs(this.pointOffset(cursor));\n        var rangeIndices = this.totalRangeIndices();\n        var range = rangeIndices.max - rangeIndices.min;\n        var delta = this.scaleToDelta(scale, range);\n        var minDelta = position * delta;\n        var maxDelta = (1 - position) * delta;\n        var min = rangeIndices.min + minDelta;\n        var max = rangeIndices.max - maxDelta;\n\n        if (max - min < MIN_CATEGORY_RANGE) {\n            max = min + MIN_CATEGORY_RANGE;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.zoomRange = function zoomRange (scale, cursor) {\n        var ref = this.totalRange();\n        var totalMin = ref.min;\n        var totalMax = ref.max;\n        var range = this.scaleRange(scale, cursor);\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax)\n        };\n    };\n\n    CategoryAxis.prototype.labelsCount = function labelsCount () {\n        var labelsRange = this.labelsRange();\n\n        return labelsRange.max - labelsRange.min;\n    };\n\n    CategoryAxis.prototype.labelsRange = function labelsRange () {\n        var options = this.options;\n        var justified = options.justified;\n        var labelOptions = options.labels;\n        var ref = this.totalRangeIndices(true);\n        var min = ref.min;\n        var max = ref.max;\n        var start = Math.floor(min);\n\n        if (!justified) {\n            min = Math.floor(min);\n            max = Math.ceil(max);\n        } else {\n            min = Math.ceil(min);\n            max = Math.floor(max);\n        }\n\n        var skip;\n\n        if (min > labelOptions.skip) {\n            skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n        } else {\n            skip = labelOptions.skip;\n        }\n\n        return {\n            min: skip - start,\n            max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n        };\n    };\n\n    CategoryAxis.prototype.createAxisLabel = function createAxisLabel (index, labelOptions, labelContext) {\n        var options = this.options;\n        var dataItem = options.dataItems ? options.dataItems[index] : null;\n        var category = valueOrDefault(options.categories[index], \"\");\n\n        labelContext.dataItem = dataItem;\n        var text = this.axisLabelText(category, labelOptions, labelContext);\n\n        return new AxisLabel(category, text, index, dataItem, labelOptions);\n    };\n\n    CategoryAxis.prototype.shouldRenderNote = function shouldRenderNote (value) {\n        var range = this.totalRangeIndices();\n\n        return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n    };\n\n    CategoryAxis.prototype.noteSlot = function noteSlot (value) {\n        var options = this.options;\n        var index = value - Math.floor(options.min || 0);\n        return this.getSlot(index);\n    };\n\n    CategoryAxis.prototype.arrangeNotes = function arrangeNotes () {\n        Axis.prototype.arrangeNotes.call(this);\n        this.hideOutOfRangeNotes();\n    };\n\n    CategoryAxis.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes () {\n        var ref = this;\n        var notes = ref.notes;\n        var box = ref.box;\n        if (notes && notes.length) {\n            var valueAxis = this.options.vertical ? Y : X;\n            var start = box[valueAxis + 1];\n            var end = box[valueAxis + 2];\n\n            for (var idx = 0; idx < notes.length; idx++) {\n                var note = notes[idx];\n                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                    note.hide();\n                }\n            }\n        }\n    };\n\n    CategoryAxis.prototype.pan = function pan (delta) {\n        var range = this.totalRangeIndices(true);\n        var ref = this.scaleOptions();\n        var scale = ref.scale;\n        var offset = round(delta / scale, DEFAULT_PRECISION);\n        var totalRange = this.totalRange();\n        var min = range.min + offset;\n        var max = range.max + offset;\n\n        return this.limitRange(min, max, 0, totalRange.max, offset);\n    };\n\n    CategoryAxis.prototype.pointsRange = function pointsRange (start, end) {\n        var ref = this.options;\n        var reverse = ref.reverse;\n        var vertical = ref.vertical;\n        var valueAxis = vertical ? Y : X;\n        var range = this.totalRangeIndices(true);\n        var ref$1 = this.scaleOptions();\n        var scale = ref$1.scale;\n        var box = ref$1.box;\n        var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n        var diffStart = start[valueAxis] - lineStart;\n        var diffEnd = end[valueAxis] - lineStart;\n\n        var min = range.min + diffStart / scale;\n        var max = range.min + diffEnd / scale;\n        var rangeMin = Math.min(min, max);\n        var rangeMax = Math.max(min, max);\n\n        if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n            return {\n                min: rangeMin,\n                max: rangeMax\n            };\n        }\n    };\n\n    CategoryAxis.prototype.valueRange = function valueRange () {\n        return this.range();\n    };\n\n    CategoryAxis.prototype.totalIndex = function totalIndex (value) {\n        var options = this.options;\n        var index = this._categoriesMap ?\n            this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n        return index;\n    };\n\n    CategoryAxis.prototype.currentRangeIndices = function currentRangeIndices () {\n        var options = this.options;\n        var min = 0;\n\n        if (isNumber(options.min)) {\n            min = Math.floor(options.min);\n        }\n\n        var max;\n        if (isNumber(options.max)) {\n            max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n        } else {\n            max = this.totalCount() - 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    CategoryAxis.prototype.mapCategories = function mapCategories () {\n        if (!this._categoriesMap) {\n            var map = this._categoriesMap = new HashMap();\n            var srcCategories = this.options.srcCategories;\n            for (var idx = 0; idx < srcCategories.length; idx++) {\n                map.set(srcCategories[idx], idx);\n            }\n        }\n    };\n\n    CategoryAxis.prototype.totalCount = function totalCount () {\n        return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n    };\n\n    return CategoryAxis;\n}(Axis));\n\nsetDefaultOptions(CategoryAxis, {\n    type: \"category\",\n    vertical: false,\n    majorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        zIndex: 1\n    },\n    justified: false,\n    _deferLabels: true\n});\n\nexport default CategoryAxis;\n"]},"metadata":{},"sourceType":"module"}