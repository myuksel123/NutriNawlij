{"ast":null,"code":"import { geometry as g } from '@progress/kendo-drawing';\nimport { Class, setDefaultOptions, limitValue, rad, deg, deepExtend } from '../common';\nimport { Location } from './location';\nimport { datums } from './datums';\nvar math = Math,\n    atan = math.atan,\n    exp = math.exp,\n    pow = math.pow,\n    sin = math.sin,\n    log = math.log,\n    tan = math.tan,\n    Point = g.Point;\nvar PI = math.PI,\n    PI_DIV_2 = PI / 2,\n    PI_DIV_4 = PI / 4,\n    DEG_TO_RAD = PI / 180;\nvar WGS84 = datums.WGS84; // WGS 84 / World Mercator\n\nexport var Mercator = function (Class) {\n  function Mercator(options) {\n    Class.call(this);\n    this.initProperties();\n\n    this._initOptions(options);\n  }\n\n  if (Class) Mercator.__proto__ = Class;\n  Mercator.prototype = Object.create(Class && Class.prototype);\n  Mercator.prototype.constructor = Mercator;\n\n  Mercator.prototype._initOptions = function _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  };\n\n  Mercator.prototype.initProperties = function initProperties() {\n    // super.initProperties();\n    deepExtend(this, {\n      MAX_LNG: 180,\n      MAX_LAT: 85.0840590501,\n      INVERSE_ITERATIONS: 15,\n      INVERSE_CONVERGENCE: 1e-12\n    });\n  };\n\n  Mercator.prototype.forward = function forward(loc, clamp) {\n    var proj = this,\n        options = proj.options,\n        datum = options.datum,\n        r = datum.a,\n        lng0 = options.centralMeridian,\n        lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT),\n        lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng,\n        x = rad(lng - lng0) * r,\n        y = proj._projectLat(lat);\n\n    return new Point(x, y);\n  };\n\n  Mercator.prototype._projectLat = function _projectLat(lat) {\n    var datum = this.options.datum,\n        ecc = datum.e,\n        r = datum.a,\n        y = rad(lat),\n        ts = tan(PI_DIV_4 + y / 2),\n        con = ecc * sin(y),\n        p = pow((1 - con) / (1 + con), ecc / 2); // See: http://en.wikipedia.org/wiki/Mercator_projection#Generalization_to_the_ellipsoid\n\n    return r * log(ts * p);\n  };\n\n  Mercator.prototype.inverse = function inverse(point, clamp) {\n    var proj = this,\n        options = proj.options,\n        datum = options.datum,\n        r = datum.a,\n        lng0 = options.centralMeridian,\n        lng = point.x / (DEG_TO_RAD * r) + lng0,\n        lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);\n\n    if (clamp) {\n      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);\n    }\n\n    return new Location(lat, lng);\n  };\n\n  Mercator.prototype._inverseY = function _inverseY(y) {\n    var proj = this,\n        datum = proj.options.datum,\n        r = datum.a,\n        ecc = datum.e,\n        ecch = ecc / 2,\n        ts = exp(-y / r),\n        phi = PI_DIV_2 - 2 * atan(ts),\n        i;\n\n    for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {\n      var con = ecc * sin(phi),\n          p = pow((1 - con) / (1 + con), ecch),\n          dphi = PI_DIV_2 - 2 * atan(ts * p) - phi;\n      phi += dphi;\n\n      if (math.abs(dphi) <= proj.INVERSE_CONVERGENCE) {\n        break;\n      }\n    }\n\n    return deg(phi);\n  };\n\n  return Mercator;\n}(Class);\nsetDefaultOptions(Mercator, {\n  centralMeridian: 0,\n  datum: WGS84\n}); // WGS 84 / Pseudo-Mercator\n// Used by Google Maps, Bing, OSM, etc.\n// Spherical projection of ellipsoidal coordinates.\n\nexport var SphericalMercator = function (Mercator) {\n  function SphericalMercator() {\n    Mercator.apply(this, arguments);\n  }\n\n  if (Mercator) SphericalMercator.__proto__ = Mercator;\n  SphericalMercator.prototype = Object.create(Mercator && Mercator.prototype);\n  SphericalMercator.prototype.constructor = SphericalMercator;\n\n  SphericalMercator.prototype.initProperties = function initProperties() {\n    Mercator.prototype.initProperties.call(this);\n    deepExtend(this, {\n      MAX_LAT: 85.0511287798\n    });\n  };\n\n  SphericalMercator.prototype._projectLat = function _projectLat(lat) {\n    var r = this.options.datum.a,\n        y = rad(lat),\n        ts = tan(PI_DIV_4 + y / 2);\n    return r * log(ts);\n  };\n\n  SphericalMercator.prototype._inverseY = function _inverseY(y) {\n    var r = this.options.datum.a,\n        ts = exp(-y / r);\n    return deg(PI_DIV_2 - 2 * atan(ts));\n  };\n\n  return SphericalMercator;\n}(Mercator);\nexport var Equirectangular = function (Class) {\n  function Equirectangular() {\n    Class.apply(this, arguments);\n  }\n\n  if (Class) Equirectangular.__proto__ = Class;\n  Equirectangular.prototype = Object.create(Class && Class.prototype);\n  Equirectangular.prototype.constructor = Equirectangular;\n\n  Equirectangular.prototype.forward = function forward(loc) {\n    return new Point(loc.lng, loc.lat);\n  };\n\n  Equirectangular.prototype.inverse = function inverse(point) {\n    return new Location(point.y, point.x);\n  };\n\n  return Equirectangular;\n}(Class); // This is the projected coordinate system used for rendering maps in Google Maps, OpenStreetMap, etc\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Certain Web mapping and visualisation applications. It is not a recognised geodetic system: for that see ellipsoidal Mercator CRS code 3395 (WGS 84 / World Mercator).\n// Remarks: Uses spherical development of ellipsoidal coordinates. Relative to WGS 84 / World Mercator (CRS code 3395) errors of 0.7 percent in scale and differences in northing of up to 43km in the map (equivalent to 21km on the ground) may arise.\n// Area of use: World between 85.06°S and 85.06°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: m.\n// https://epsg.io/3857\n\nexport var EPSG3857 = function (Class) {\n  function EPSG3857() {\n    Class.call(this);\n    var crs = this,\n        proj = crs._proj = new SphericalMercator();\n    var c = this.c = 2 * PI * proj.options.datum.a; // transfrom matrix\n    // Scale circumference to 1, mirror Y and shift origin to top left\n\n    this._tm = g.transform().translate(0.5, 0.5).scale(1 / c, -1 / c); // Inverse transform matrix\n\n    this._itm = g.transform().scale(c, -c).translate(-0.5, -0.5);\n  }\n\n  if (Class) EPSG3857.__proto__ = Class;\n  EPSG3857.prototype = Object.create(Class && Class.prototype);\n  EPSG3857.prototype.constructor = EPSG3857; // Location <-> Point (screen coordinates for a given scale)\n\n  EPSG3857.prototype.toPoint = function toPoint(loc, scale, clamp) {\n    var point = this._proj.forward(loc, clamp);\n\n    return point.transform(this._tm).scale(scale || 1);\n  };\n\n  EPSG3857.prototype.toLocation = function toLocation(point, scale, clamp) {\n    var newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);\n    return this._proj.inverse(newPoint, clamp);\n  };\n\n  return EPSG3857;\n}(Class); // Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Very small scale mapping.\n// Remarks: Euro-centric view of world excluding polar areas.\n// Area of use: World between 80°S and 84°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (E,N). Orientations: east, north. UoM: m.\n// https://epsg.io/3395\n\nexport var EPSG3395 = function (Class) {\n  function EPSG3395() {\n    Class.call(this);\n    this._proj = new Mercator();\n  }\n\n  if (Class) EPSG3395.__proto__ = Class;\n  EPSG3395.prototype = Object.create(Class && Class.prototype);\n  EPSG3395.prototype.constructor = EPSG3395;\n\n  EPSG3395.prototype.toPoint = function toPoint(loc) {\n    return this._proj.forward(loc);\n  };\n\n  EPSG3395.prototype.toLocation = function toLocation(point) {\n    return this._proj.inverse(point);\n  };\n\n  return EPSG3395;\n}(Class); // Unit: degree\n// Geodetic CRS: WGS 84\n// Scope: Horizontal component of 3D system. Used by the GPS satellite navigation system and for NATO military geodetic surveying.\n// Area of use: World.\n// Coordinate system: Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree\n// https://epsg.io/4326\n\nexport var EPSG4326 = function (Class) {\n  function EPSG4326() {\n    Class.call(this);\n    this._proj = new Equirectangular();\n  }\n\n  if (Class) EPSG4326.__proto__ = Class;\n  EPSG4326.prototype = Object.create(Class && Class.prototype);\n  EPSG4326.prototype.constructor = EPSG4326;\n\n  EPSG4326.prototype.toPoint = function toPoint(loc) {\n    return this._proj.forward(loc);\n  };\n\n  EPSG4326.prototype.toLocation = function toLocation(point) {\n    return this._proj.inverse(point);\n  };\n\n  return EPSG4326;\n}(Class);","map":{"version":3,"sources":["/home/meryem/repos/Movie_Trend_Visualizer/client/node_modules/@progress/kendo-charts/dist/es/map/crs.js"],"names":["geometry","g","Class","setDefaultOptions","limitValue","rad","deg","deepExtend","Location","datums","math","Math","atan","exp","pow","sin","log","tan","Point","PI","PI_DIV_2","PI_DIV_4","DEG_TO_RAD","WGS84","Mercator","options","call","initProperties","_initOptions","__proto__","prototype","Object","create","constructor","MAX_LNG","MAX_LAT","INVERSE_ITERATIONS","INVERSE_CONVERGENCE","forward","loc","clamp","proj","datum","r","a","lng0","centralMeridian","lat","lng","x","y","_projectLat","ecc","e","ts","con","p","inverse","point","_inverseY","ecch","phi","i","dphi","abs","SphericalMercator","apply","arguments","Equirectangular","EPSG3857","crs","_proj","c","_tm","transform","translate","scale","_itm","toPoint","toLocation","newPoint","clone","EPSG3395","EPSG4326"],"mappings":"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","sourcesContent":["import {\n    geometry as g\n} from '@progress/kendo-drawing';\n\nimport {\n    Class,\n    setDefaultOptions,\n    limitValue,\n    rad,\n    deg,\n    deepExtend\n} from '../common';\n\nimport {\n    Location\n} from './location';\n\nimport {\n    datums\n} from './datums';\n\n\nvar math = Math,\n    atan = math.atan,\n    exp = math.exp,\n    pow = math.pow,\n    sin = math.sin,\n    log = math.log,\n    tan = math.tan,\n    Point = g.Point;\n\nvar PI = math.PI,\n    PI_DIV_2 = PI / 2,\n    PI_DIV_4 = PI / 4,\n    DEG_TO_RAD = PI / 180;\n\nvar WGS84 = datums.WGS84;\n\n// WGS 84 / World Mercator\nexport var Mercator = (function (Class) {\n    function Mercator(options) {\n        Class.call(this);\n        this.initProperties();\n        this._initOptions(options);\n    }\n\n    if ( Class ) Mercator.__proto__ = Class;\n    Mercator.prototype = Object.create( Class && Class.prototype );\n    Mercator.prototype.constructor = Mercator;\n\n    Mercator.prototype._initOptions = function _initOptions (options) {\n        this.options = deepExtend({}, this.options, options);\n    };\n\n    Mercator.prototype.initProperties = function initProperties () {\n        // super.initProperties();\n\n        deepExtend(this, {\n            MAX_LNG: 180,\n            MAX_LAT: 85.0840590501,\n            INVERSE_ITERATIONS: 15,\n            INVERSE_CONVERGENCE: 1e-12\n        });\n    };\n\n    Mercator.prototype.forward = function forward (loc, clamp) {\n        var proj = this,\n            options = proj.options,\n            datum = options.datum,\n            r = datum.a,\n            lng0 = options.centralMeridian,\n            lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT),\n            lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng,\n            x = rad(lng - lng0) * r,\n            y = proj._projectLat(lat);\n        return new Point(x, y);\n    };\n    Mercator.prototype._projectLat = function _projectLat (lat) {\n        var datum = this.options.datum,\n            ecc = datum.e,\n            r = datum.a,\n            y = rad(lat),\n            ts = tan(PI_DIV_4 + y / 2),\n            con = ecc * sin(y),\n            p = pow((1 - con) / (1 + con), ecc / 2);\n\n        // See: http://en.wikipedia.org/wiki/Mercator_projection#Generalization_to_the_ellipsoid\n        return r * log(ts * p);\n    };\n    Mercator.prototype.inverse = function inverse (point, clamp) {\n        var proj = this,\n            options = proj.options,\n            datum = options.datum,\n            r = datum.a,\n            lng0 = options.centralMeridian,\n            lng = point.x / (DEG_TO_RAD * r) + lng0,\n            lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);\n        if (clamp) {\n            lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);\n        }\n        return new Location(lat, lng);\n    };\n    Mercator.prototype._inverseY = function _inverseY (y) {\n        var proj = this,\n            datum = proj.options.datum,\n            r = datum.a,\n            ecc = datum.e,\n            ecch = ecc / 2,\n            ts = exp(-y / r),\n            phi = PI_DIV_2 - 2 * atan(ts),\n            i;\n        for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {\n            var con = ecc * sin(phi),\n                p = pow((1 - con) / (1 + con), ecch),\n                dphi = PI_DIV_2 - 2 * atan(ts * p) - phi;\n            phi += dphi;\n            if (math.abs(dphi) <= proj.INVERSE_CONVERGENCE) {\n                break;\n            }\n        }\n        return deg(phi);\n    };\n\n    return Mercator;\n}(Class));\n\nsetDefaultOptions(Mercator, {\n    centralMeridian: 0,\n    datum: WGS84\n});\n\n\n// WGS 84 / Pseudo-Mercator\n// Used by Google Maps, Bing, OSM, etc.\n// Spherical projection of ellipsoidal coordinates.\nexport var SphericalMercator = (function (Mercator) {\n    function SphericalMercator () {\n        Mercator.apply(this, arguments);\n    }\n\n    if ( Mercator ) SphericalMercator.__proto__ = Mercator;\n    SphericalMercator.prototype = Object.create( Mercator && Mercator.prototype );\n    SphericalMercator.prototype.constructor = SphericalMercator;\n\n    SphericalMercator.prototype.initProperties = function initProperties () {\n        Mercator.prototype.initProperties.call(this);\n\n        deepExtend(this, {\n            MAX_LAT: 85.0511287798\n        });\n    };\n\n    SphericalMercator.prototype._projectLat = function _projectLat (lat) {\n        var r = this.options.datum.a,\n            y = rad(lat),\n            ts = tan(PI_DIV_4 + y / 2);\n        return r * log(ts);\n    };\n\n    SphericalMercator.prototype._inverseY = function _inverseY (y) {\n        var r = this.options.datum.a,\n            ts = exp(-y / r);\n        return deg(PI_DIV_2 - 2 * atan(ts));\n    };\n\n    return SphericalMercator;\n}(Mercator));\n\nexport var Equirectangular = (function (Class) {\n    function Equirectangular () {\n        Class.apply(this, arguments);\n    }\n\n    if ( Class ) Equirectangular.__proto__ = Class;\n    Equirectangular.prototype = Object.create( Class && Class.prototype );\n    Equirectangular.prototype.constructor = Equirectangular;\n\n    Equirectangular.prototype.forward = function forward (loc) {\n        return new Point(loc.lng, loc.lat);\n    };\n    Equirectangular.prototype.inverse = function inverse (point) {\n        return new Location(point.y, point.x);\n    };\n\n    return Equirectangular;\n}(Class));\n\n// This is the projected coordinate system used for rendering maps in Google Maps, OpenStreetMap, etc\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Certain Web mapping and visualisation applications. It is not a recognised geodetic system: for that see ellipsoidal Mercator CRS code 3395 (WGS 84 / World Mercator).\n// Remarks: Uses spherical development of ellipsoidal coordinates. Relative to WGS 84 / World Mercator (CRS code 3395) errors of 0.7 percent in scale and differences in northing of up to 43km in the map (equivalent to 21km on the ground) may arise.\n// Area of use: World between 85.06°S and 85.06°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: m.\n// https://epsg.io/3857\nexport var EPSG3857 = (function (Class) {\n    function EPSG3857() {\n        Class.call(this);\n        var crs = this,\n            proj = crs._proj = new SphericalMercator();\n        var c = this.c = 2 * PI * proj.options.datum.a;\n\n        // transfrom matrix\n        // Scale circumference to 1, mirror Y and shift origin to top left\n        this._tm = g.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);\n\n        // Inverse transform matrix\n        this._itm = g.transform().scale(c, -c).translate(-0.5, -0.5);\n    }\n\n    if ( Class ) EPSG3857.__proto__ = Class;\n    EPSG3857.prototype = Object.create( Class && Class.prototype );\n    EPSG3857.prototype.constructor = EPSG3857;\n\n    // Location <-> Point (screen coordinates for a given scale)\n    EPSG3857.prototype.toPoint = function toPoint (loc, scale, clamp) {\n        var point = this._proj.forward(loc, clamp);\n        return point.transform(this._tm).scale(scale || 1);\n    };\n    EPSG3857.prototype.toLocation = function toLocation (point, scale, clamp) {\n        var newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);\n        return this._proj.inverse(newPoint, clamp);\n    };\n\n    return EPSG3857;\n}(Class));\n\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Very small scale mapping.\n// Remarks: Euro-centric view of world excluding polar areas.\n// Area of use: World between 80°S and 84°N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (E,N). Orientations: east, north. UoM: m.\n// https://epsg.io/3395\nexport var EPSG3395 = (function (Class) {\n    function EPSG3395() {\n        Class.call(this);\n        this._proj = new Mercator();\n    }\n\n    if ( Class ) EPSG3395.__proto__ = Class;\n    EPSG3395.prototype = Object.create( Class && Class.prototype );\n    EPSG3395.prototype.constructor = EPSG3395;\n    EPSG3395.prototype.toPoint = function toPoint (loc) {\n        return this._proj.forward(loc);\n    };\n    EPSG3395.prototype.toLocation = function toLocation (point) {\n        return this._proj.inverse(point);\n    };\n\n    return EPSG3395;\n}(Class));\n\n// Unit: degree\n// Geodetic CRS: WGS 84\n// Scope: Horizontal component of 3D system. Used by the GPS satellite navigation system and for NATO military geodetic surveying.\n// Area of use: World.\n// Coordinate system: Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree\n// https://epsg.io/4326\nexport var EPSG4326 = (function (Class) {\n    function EPSG4326() {\n        Class.call(this);\n        this._proj = new Equirectangular();\n    }\n\n    if ( Class ) EPSG4326.__proto__ = Class;\n    EPSG4326.prototype = Object.create( Class && Class.prototype );\n    EPSG4326.prototype.constructor = EPSG4326;\n    EPSG4326.prototype.toPoint = function toPoint (loc) {\n        return this._proj.forward(loc);\n    };\n    EPSG4326.prototype.toLocation = function toLocation (point) {\n        return this._proj.inverse(point);\n    };\n\n    return EPSG4326;\n}(Class));\n"]},"metadata":{},"sourceType":"module"}